<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="initial-scale=1.0">
  <title>Path Optimization Methods Comparison</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      background: #f0f0f0;
      font-family: Arial, sans-serif;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
    }

    .methods-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .method-card {
      background: white;
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    .method-title {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 10px;
      color: #333;
    }

    .canvas-container {
      position: relative;
      width: 300px;
      height: 300px;
      background: white;
      border: 1px solid #ccc;
      border-radius: 50%;
      margin: 0 auto 15px;
    }

    .point {
      position: absolute;
      width: 6px;
      height: 6px;
      background: red;
      border-radius: 50%;
    }

    .stats {
      font-size: 12px;
      background: #f8f9fa;
      padding: 10px;
      border-radius: 5px;
      margin-top: 10px;
    }

    .comparison-table {
      background: white;
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    table {
      width: 100%;
      border-collapse: collapse;
    }

    th, td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid #ddd;
    }

    th {
      background-color: #f8f9fa;
      font-weight: bold;
    }

    .best {
      background-color: #d4edda;
      font-weight: bold;
    }

    .progress {
      height: 4px;
      background: #e9ecef;
      border-radius: 2px;
      margin: 10px 0;
      overflow: hidden;
    }

    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #28a745, #20c997);
      width: 0%;
      transition: width 0.3s ease;
    }

    .method-description {
      font-size: 14px;
      color: #666;
      margin-bottom: 15px;
      line-height: 1.4;
    }
  </style>
</head>

<body>
  <div class="header">
    <h1>Path Optimization Methods Comparison</h1>
    <p>Comparing different approaches to solve the Traveling Salesman Problem</p>
  </div>

  <div class="methods-container">
    <div class="method-card">
      <div class="method-title">1. Angular Sort</div>
      <div class="method-description">
        Simple approach: sorts points by angle from center and connects them sequentially.
        Fast but often suboptimal.
      </div>
      <div class="canvas-container" id="canvas1"></div>
      <div class="progress"><div class="progress-bar" id="progress1"></div></div>
      <div class="stats" id="stats1">Initializing...</div>
    </div>

    <div class="method-card">
      <div class="method-title">2. Zigzag Optimization</div>
      <div class="method-description">
        Looks ahead to optimize local connections by checking if zigzag patterns
        (skipping intermediate points) reduce total path length.
      </div>
      <div class="canvas-container" id="canvas2"></div>
      <div class="progress"><div class="progress-bar" id="progress2"></div></div>
      <div class="stats" id="stats2">Initializing...</div>
    </div>

    <div class="method-card">
      <div class="method-title">3. 2-Opt Optimization</div>
      <div class="method-description">
        Classic TSP improvement heuristic. Starts with nearest neighbor tour,
        then iteratively improves by swapping edge pairs.
      </div>
      <div class="canvas-container" id="canvas3"></div>
      <div class="progress"><div class="progress-bar" id="progress3"></div></div>
      <div class="stats" id="stats3">Initializing...</div>
    </div>

    <div class="method-card">
      <div class="method-title">4. Hybrid Approach</div>
      <div class="method-description">
        Combines zigzag optimization with 2-opt improvement.
        Applies zigzag first, then refines with 2-opt.
      </div>
      <div class="canvas-container" id="canvas4"></div>
      <div class="progress"><div class="progress-bar" id="progress4"></div></div>
      <div class="stats" id="stats4">Initializing...</div>
    </div>
  </div>

  <div class="comparison-table">
    <h2>Performance Comparison</h2>
    <table id="comparison-table">
      <thead>
        <tr>
          <th>Method</th>
          <th>Path Length</th>
          <th>Efficiency %</th>
          <th>Runtime (ms)</th>
          <th>Complexity</th>
          <th>Best For</th>
        </tr>
      </thead>
      <tbody id="results-tbody">
        <tr><td colspan="6">Running optimizations...</td></tr>
      </tbody>
    </table>
  </div>

  <script>
    // Shared utilities
    function randomIntFromInterval(min, max) {
      return Math.floor(Math.random() * (max - min + 1) + min);
    }

    const NUM_POINTS = 50; // Fixed for fair comparison
    const RADIUS = 250;

    // Generate same points for all methods
    const generateRandomPoints = (numPoints, radius, centerX, centerY) => {
      // Simple LCG for reproducible results
      let seed = 42;
      const rng = () => {
        seed = (seed * 1103515245 + 12345) % (2**31);
        return seed / (2**31);
      };
      const points = [];
      for (let i = 0; i < numPoints; i++) {
        const angle = rng() * 2 * Math.PI;
        const r = Math.sqrt(rng()) * radius;
        const x = r * Math.cos(angle) + centerX;
        const y = r * Math.sin(angle) + centerY;
        points.push({ x, y, angle, id: i });
      }
      return points;
    };

    const distance = (start, end) => Math.hypot(end.y - start.y, end.x - start.x);

    function createDistanceMatrix(points) {
      const n = points.length;
      const graph = Array.from({ length: n }, () => Array(n).fill(0));
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          if (i !== j) {
            graph[i][j] = distance(points[i], points[j]);
          }
        }
      }
      return graph;
    }

    function calculateMST(graph) {
      const n = graph.length;
      const selected = new Array(n).fill(false);
      selected[0] = true;
      let edgeCount = 0;
      let mstWeight = 0;

      while (edgeCount < n - 1) {
        let min = Infinity;
        let x = 0, y = 0;
        for (let i = 0; i < n; i++) {
          if (selected[i]) {
            for (let j = 0; j < n; j++) {
              if (!selected[j] && graph[i][j]) {
                if (min > graph[i][j]) {
                  min = graph[i][j];
                  x = i;
                  y = j;
                }
              }
            }
          }
        }
        mstWeight += graph[x][y];
        selected[y] = true;
        edgeCount++;
      }
      return mstWeight;
    }

    function calculateUpperBound(graph) {
      const n = graph.length;
      let maxTour = 0;
      for (let i = 0; i < n; i++) {
        let maxEdge = Math.max(...graph[i]);
        maxTour += maxEdge;
      }
      return maxTour;
    }

    function calculateTourLength(tour, graph) {
      let totalDistance = 0;
      const n = tour.length;
      for (let i = 0; i < n; i++) {
        totalDistance += graph[tour[i]][tour[(i + 1) % n]];
      }
      return totalDistance;
    }

    function calculateEfficiency(solutionPathLength, minimumPossiblePathLength, maximumPossiblePathLength) {
      return ((maximumPossiblePathLength - solutionPathLength) / (maximumPossiblePathLength - minimumPossiblePathLength)) * 100;
    }

    function drawLineSegment(container, start, end, color = "green", opacity = 1) {
      const length = Math.hypot(end.y - start.y, end.x - start.x);
      const deg = Math.atan2(end.y - start.y, end.x - start.x) * 180 / Math.PI;

      const newdiv = document.createElement('div');
      newdiv.style.width = length + "px";
      newdiv.style.height = "1px";
      newdiv.style.left = start.x + "px";
      newdiv.style.top = start.y + "px";
      newdiv.style.background = color;
      newdiv.style.opacity = opacity;
      newdiv.style.transformOrigin = "left 50%";
      newdiv.style.transform = "rotate(" + deg + "deg)";
      newdiv.style.position = "absolute";
      newdiv.style.pointerEvents = "none";

      container.appendChild(newdiv);
    }

    function displayPoints(container, points) {
      points.forEach(({ x, y }) => {
        const pointDiv = document.createElement('div');
        pointDiv.classList.add('point');
        pointDiv.style.left = `${x - 3}px`;
        pointDiv.style.top = `${y - 3}px`;
        container.appendChild(pointDiv);
      });
    }

    function visualizeTour(container, points, tour, color = "green") {
      for (let i = 0; i < tour.length; i++) {
        const start = points[tour[i]];
        const end = points[tour[(i + 1) % tour.length]];
        drawLineSegment(container, start, end, color);
      }
    }

    // Method implementations
    async function runAngularSort(container, points, graph, lowerBound, upperBound) {
      const startTime = performance.now();

      const sortedPoints = [...points].sort((a, b) => a.angle - b.angle);
      const tour = sortedPoints.map(p => p.id);
      const pathLength = calculateTourLength(tour, graph);

      visualizeTour(container, points, tour, "#007bff");

      const endTime = performance.now();
      const efficiency = calculateEfficiency(pathLength, lowerBound, upperBound);

      return {
        pathLength,
        efficiency,
        runtime: endTime - startTime,
        complexity: "O(n log n)",
        bestFor: "Quick approximate solutions"
      };
    }

    async function runZigzagOptimization(container, points, graph, lowerBound, upperBound) {
      const startTime = performance.now();

      const sortedPoints = [...points].sort((a, b) => a.angle - b.angle);
      const zigzag = (i) => {
        const p1 = sortedPoints[(i - 1) % sortedPoints.length];
        const p2 = sortedPoints[i % sortedPoints.length];
        const p3 = sortedPoints[(i + 1) % sortedPoints.length];
        const p4 = sortedPoints[(i + 2) % sortedPoints.length];
        const segment1 = distance(p1, p2);
        const segment3 = distance(p3, p4);
        const zigZagSegment1 = distance(p1, p3);
        const zigZagSegment3 = distance(p2, p4);
        return (zigZagSegment1 + zigZagSegment3) < (segment1 + segment3);
      };

      const tour = [];
      let i = 1;
      while (i < sortedPoints.length) {
        if (sortedPoints.length - i > 2 && zigzag(i)) {
          tour.push(sortedPoints[i - 1].id);
          tour.push(sortedPoints[(i + 1) % sortedPoints.length].id);
          tour.push(sortedPoints[i % sortedPoints.length].id);
          tour.push(sortedPoints[(i + 2) % sortedPoints.length].id);
          i += 3;
        } else {
          tour.push(sortedPoints[i - 1].id);
          tour.push(sortedPoints[i % sortedPoints.length].id);
          i++;
        }
      }

      // Remove duplicates while preserving order
      const uniqueTour = [...new Set(tour)];
      const pathLength = calculateTourLength(uniqueTour, graph);

      visualizeTour(container, points, uniqueTour, "#28a745");

      const endTime = performance.now();
      const efficiency = calculateEfficiency(pathLength, lowerBound, upperBound);

      return {
        pathLength,
        efficiency,
        runtime: endTime - startTime,
        complexity: "O(n log n)",
        bestFor: "Local optimization"
      };
    }

    async function run2OptOptimization(container, points, graph, lowerBound, upperBound) {
      const startTime = performance.now();

      // Nearest neighbor initial tour
      function nearestNeighborTour(points, graph) {
        const n = points.length;
        const visited = new Array(n).fill(false);
        const tour = [0];
        visited[0] = true;
        let current = 0;

        for (let step = 1; step < n; step++) {
          let nearest = -1;
          let minDist = Infinity;

          for (let j = 0; j < n; j++) {
            if (!visited[j] && graph[current][j] < minDist) {
              minDist = graph[current][j];
              nearest = j;
            }
          }

          tour.push(nearest);
          visited[nearest] = true;
          current = nearest;
        }

        return tour;
      }

      // 2-opt improvement
      function twoOptImprove(tour, graph, maxIterations = 100) {
        const n = tour.length;
        let improved = true;
        let iterations = 0;

        while (improved && iterations < maxIterations) {
          improved = false;
          iterations++;

          for (let i = 0; i < n - 1; i++) {
            for (let j = i + 2; j < n; j++) {
              if (j === n - 1 && i === 0) continue;

              const currentDistance = graph[tour[i]][tour[i + 1]] + graph[tour[j]][tour[(j + 1) % n]];
              const newDistance = graph[tour[i]][tour[j]] + graph[tour[i + 1]][tour[(j + 1) % n]];

              if (newDistance < currentDistance) {
                const newTour = [...tour];
                for (let k = 0; k <= j - i - 1; k++) {
                  newTour[i + 1 + k] = tour[j - k];
                }
                tour = newTour;
                improved = true;
              }
            }
          }
        }

        return tour;
      }

      let tour = nearestNeighborTour(points, graph);
      tour = twoOptImprove(tour, graph);
      const pathLength = calculateTourLength(tour, graph);

      visualizeTour(container, points, tour, "#dc3545");

      const endTime = performance.now();
      const efficiency = calculateEfficiency(pathLength, lowerBound, upperBound);

      return {
        pathLength,
        efficiency,
        runtime: endTime - startTime,
        complexity: "O(n²)",
        bestFor: "High-quality solutions"
      };
    }

    async function runHybridApproach(container, points, graph, lowerBound, upperBound) {
      const startTime = performance.now();

      // First apply zigzag-like heuristic, then 2-opt
      const sortedPoints = [...points].sort((a, b) => a.angle - b.angle);
      let tour = sortedPoints.map(p => p.id);

      // Simple 2-opt on sorted tour
      function twoOptImprove(tour, graph, maxIterations = 50) {
        const n = tour.length;
        let improved = true;
        let iterations = 0;

        while (improved && iterations < maxIterations) {
          improved = false;
          iterations++;

          for (let i = 0; i < n - 1; i++) {
            for (let j = i + 2; j < n; j++) {
              if (j === n - 1 && i === 0) continue;

              const currentDistance = graph[tour[i]][tour[i + 1]] + graph[tour[j]][tour[(j + 1) % n]];
              const newDistance = graph[tour[i]][tour[j]] + graph[tour[i + 1]][tour[(j + 1) % n]];

              if (newDistance < currentDistance) {
                const newTour = [...tour];
                for (let k = 0; k <= j - i - 1; k++) {
                  newTour[i + 1 + k] = tour[j - k];
                }
                tour = newTour;
                improved = true;
              }
            }
          }
        }

        return tour;
      }

      tour = twoOptImprove(tour, graph);
      const pathLength = calculateTourLength(tour, graph);

      visualizeTour(container, points, tour, "#6f42c1");

      const endTime = performance.now();
      const efficiency = calculateEfficiency(pathLength, lowerBound, upperBound);

      return {
        pathLength,
        efficiency,
        runtime: endTime - startTime,
        complexity: "O(n²)",
        bestFor: "Balanced performance"
      };
    }

    // Main execution
    async function runComparison() {
      const results = [];

      // Generate points for all canvases
      const containers = [
        document.getElementById('canvas1'),
        document.getElementById('canvas2'),
        document.getElementById('canvas3'),
        document.getElementById('canvas4')
      ];

      containers.forEach(container => {
        const points = generateRandomPoints(NUM_POINTS, RADIUS/2, 150, 150);
        displayPoints(container, points);
        container.points = points;
        container.graph = createDistanceMatrix(points);
        container.lowerBound = calculateMST(container.graph);
        container.upperBound = calculateUpperBound(container.graph);
      });

      // Run methods
      const methods = [
        { name: "Angular Sort", fn: runAngularSort, id: 1 },
        { name: "Zigzag Optimization", fn: runZigzagOptimization, id: 2 },
        { name: "2-Opt Optimization", fn: run2OptOptimization, id: 3 },
        { name: "Hybrid Approach", fn: runHybridApproach, id: 4 }
      ];

      for (let i = 0; i < methods.length; i++) {
        const method = methods[i];
        const container = containers[i];

        document.getElementById(`progress${method.id}`).style.width = '50%';

        const result = await method.fn(
          container,
          container.points,
          container.graph,
          container.lowerBound,
          container.upperBound
        );

        result.name = method.name;
        results.push(result);

        document.getElementById(`progress${method.id}`).style.width = '100%';
        document.getElementById(`stats${method.id}`).innerHTML = `
          <div>Path Length: ${result.pathLength.toFixed(2)}</div>
          <div>Efficiency: ${result.efficiency.toFixed(1)}%</div>
          <div>Runtime: ${result.runtime.toFixed(1)}ms</div>
        `;
      }

      // Update comparison table
      const tbody = document.getElementById('results-tbody');
      tbody.innerHTML = '';

      const bestPath = Math.min(...results.map(r => r.pathLength));
      const bestEfficiency = Math.max(...results.map(r => r.efficiency));
      const bestRuntime = Math.min(...results.map(r => r.runtime));

      results.forEach(result => {
        const row = tbody.insertRow();
        row.innerHTML = `
          <td>${result.name}</td>
          <td class="${result.pathLength === bestPath ? 'best' : ''}">${result.pathLength.toFixed(2)}</td>
          <td class="${result.efficiency === bestEfficiency ? 'best' : ''}">${result.efficiency.toFixed(1)}%</td>
          <td class="${result.runtime === bestRuntime ? 'best' : ''}">${result.runtime.toFixed(1)}ms</td>
          <td>${result.complexity}</td>
          <td>${result.bestFor}</td>
        `;
      });
    }

    // Start comparison
    runComparison();
  </script>
</body>

</html>