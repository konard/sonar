<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="initial-scale=1.0">
  <title>Path Optimization Methods Comparison</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      background: #f0f0f0;
      font-family: Arial, sans-serif;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
    }

    .methods-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .method-card {
      background: white;
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    .method-title {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 10px;
      color: #333;
    }

    .canvas-container {
      position: relative;
      width: 100%;
      padding-bottom: 100%; /* Maintain aspect ratio 1:1 */
      background: white;
      border: 1px solid #ccc;
      border-radius: 50%;
      margin: 0 auto 15px;
      box-sizing: border-box;
    }

    .canvas-inner {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .point {
      position: absolute;
      width: 6px;
      height: 6px;
      background: red;
      border-radius: 50%;
    }

    .stats {
      font-size: 12px;
      background: #f8f9fa;
      padding: 10px;
      border-radius: 5px;
      margin-top: 10px;
    }

    .comparison-table {
      background: white;
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    table {
      width: 100%;
      border-collapse: collapse;
    }

    th, td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid #ddd;
    }

    th {
      background-color: #f8f9fa;
      font-weight: bold;
    }

    .best {
      background-color: #d4edda;
      font-weight: bold;
    }

    .progress {
      height: 4px;
      background: #e9ecef;
      border-radius: 2px;
      margin: 10px 0;
      overflow: hidden;
    }

    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #28a745, #20c997);
      width: 0%;
      transition: width 0.3s ease;
    }

    .method-description {
      font-size: 14px;
      color: #666;
      margin-bottom: 15px;
      line-height: 1.4;
    }
  </style>
</head>

<body>
  <div class="header">
    <h1>Path Optimization Methods Comparison</h1>
    <p>Comparing different approaches to solve the Traveling Salesman Problem</p>
    <p id="grid-info" style="font-size: 12px; color: #666; margin-top: 10px;"></p>
  </div>

  <div class="methods-container">
    <div class="method-card">
      <div class="method-title">1. Angular Sort</div>
      <div class="method-description">
        Simple approach: sorts points by angle from center and connects them sequentially.
        Fast but often suboptimal.
      </div>
      <div class="canvas-container"><div class="canvas-inner" id="canvas1"></div></div>
      <div class="progress"><div class="progress-bar" id="progress1"></div></div>
      <div class="stats" id="stats1">Initializing...</div>
    </div>

    <div class="method-card">
      <div class="method-title">2. Zigzag Optimization</div>
      <div class="method-description">
        Looks ahead to optimize local connections by checking if zigzag patterns
        (skipping intermediate points) reduce total path length.
      </div>
      <div class="canvas-container"><div class="canvas-inner" id="canvas2"></div></div>
      <div class="progress"><div class="progress-bar" id="progress2"></div></div>
      <div class="stats" id="stats2">Initializing...</div>
    </div>

    <div class="method-card">
      <div class="method-title">3. 2-Opt Optimization</div>
      <div class="method-description">
        Classic TSP improvement heuristic. Starts with nearest neighbor tour,
        then iteratively improves by swapping edge pairs.
      </div>
      <div class="canvas-container"><div class="canvas-inner" id="canvas3"></div></div>
      <div class="progress"><div class="progress-bar" id="progress3"></div></div>
      <div class="stats" id="stats3">Initializing...</div>
    </div>

    <div class="method-card">
      <div class="method-title">4. Hybrid: 2-Opt → Zigzag</div>
      <div class="method-description">
        Applies 2-opt optimization first, then refines with zigzag.
        Combines global edge swapping with local path improvements.
      </div>
      <div class="canvas-container"><div class="canvas-inner" id="canvas4"></div></div>
      <div class="progress"><div class="progress-bar" id="progress4"></div></div>
      <div class="stats" id="stats4">Initializing...</div>
    </div>

    <div class="method-card">
      <div class="method-title">5. Hybrid: Zigzag → 2-Opt</div>
      <div class="method-description">
        Applies zigzag optimization first, then refines with 2-opt.
        Local improvements followed by global edge swapping.
      </div>
      <div class="canvas-container"><div class="canvas-inner" id="canvas5"></div></div>
      <div class="progress"><div class="progress-bar" id="progress5"></div></div>
      <div class="stats" id="stats5">Initializing...</div>
    </div>

    <div class="method-card">
      <div class="method-title">6. Sonar Visit</div>
      <div class="method-description">
        360° rotation sweep in fixed angle steps. Points on the same angle are connected sequentially.
        Constant-time O(1) angle steps regardless of point count.
      </div>
      <div class="canvas-container"><div class="canvas-inner" id="canvas6"></div></div>
      <div class="progress"><div class="progress-bar" id="progress6"></div></div>
      <div class="stats" id="stats6">Initializing...</div>
    </div>
  </div>

  <div class="comparison-table">
    <h2>Performance Comparison</h2>
    <table id="comparison-table">
      <thead>
        <tr>
          <th>Method</th>
          <th>Path Length</th>
          <th>Efficiency %</th>
          <th>Runtime (ms)</th>
          <th>Complexity</th>
          <th>Best For</th>
        </tr>
      </thead>
      <tbody id="results-tbody">
        <tr><td colspan="6">Running optimizations...</td></tr>
      </tbody>
    </table>
    <div style="font-size: 12px; color: #666; margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 5px;">
      <strong>Complexity Notes:</strong><br>
      • <strong>Angular Sort O(n log n)</strong>: Dominated by the sorting step<br>
      • <strong>Sonar Visit O(1)*</strong>: The angle sweep uses a fixed number of steps (4×GRID_SIZE) determined by grid resolution,
        not by point count. While point assignment to buckets is O(n), the core sweep algorithm is constant-time.
        With sufficient grid precision, all point configurations can be handled in constant angle steps.
    </div>
  </div>

  <script>
    // Shared utilities
    function randomIntFromInterval(min, max) {
      return Math.floor(Math.random() * (max - min + 1) + min);
    }

    const NUM_POINTS = 50; // Fixed for fair comparison
    const GRID_SIZE = 20; // Virtual N×N grid for point placement

    // Generate same points for all methods with random seed for variety on each reload
    const initialSeed = Math.floor(Math.random() * 1000000);

    // Generate points on a virtual N×N grid for consistent placement
    // This enables O(1) sonar visit as angle steps are determined by grid size, not point count
    const generateNormalizedPoints = (numPoints, gridSize = GRID_SIZE, seed = initialSeed) => {
      // Simple LCG for reproducible results within same page load
      let currentSeed = seed;
      const rng = () => {
        currentSeed = (currentSeed * 1103515245 + 12345) % (2**31);
        return currentSeed / (2**31);
      };

      const center = 0.5; // Normalized center
      const maxRadius = 0.45; // Leave some padding from edges

      // Generate all valid grid positions within the circular area
      const gridStep = 1 / gridSize;
      const validPositions = [];

      for (let gx = 0; gx < gridSize; gx++) {
        for (let gy = 0; gy < gridSize; gy++) {
          const x = (gx + 0.5) * gridStep;
          const y = (gy + 0.5) * gridStep;
          const dx = x - center;
          const dy = y - center;
          const distFromCenter = Math.sqrt(dx * dx + dy * dy);

          // Only include points within the circular area
          if (distFromCenter <= maxRadius) {
            const angle = Math.atan2(dy, dx);
            validPositions.push({ x, y, angle: angle < 0 ? angle + 2 * Math.PI : angle, gx, gy });
          }
        }
      }

      // Shuffle valid positions using Fisher-Yates
      for (let i = validPositions.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [validPositions[i], validPositions[j]] = [validPositions[j], validPositions[i]];
      }

      // Select numPoints from shuffled positions
      const points = validPositions.slice(0, Math.min(numPoints, validPositions.length));

      // Assign IDs
      return points.map((p, idx) => ({ ...p, id: idx }));
    };

    // Scale normalized points to actual canvas size
    const scalePoints = (normalizedPoints, canvasSize) => {
      return normalizedPoints.map(p => ({
        ...p,
        scaledX: p.x * canvasSize,
        scaledY: p.y * canvasSize
      }));
    };

    // Distance using normalized coordinates for consistent calculations
    const distance = (start, end) => Math.hypot(end.y - start.y, end.x - start.x);

    // Distance using scaled coordinates for display
    const scaledDistance = (start, end) => Math.hypot(end.scaledY - start.scaledY, end.scaledX - start.scaledX);

    function createDistanceMatrix(points) {
      const n = points.length;
      const graph = Array.from({ length: n }, () => Array(n).fill(0));
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          if (i !== j) {
            graph[i][j] = distance(points[i], points[j]);
          }
        }
      }
      return graph;
    }

    function calculateMST(graph) {
      const n = graph.length;
      const selected = new Array(n).fill(false);
      selected[0] = true;
      let edgeCount = 0;
      let mstWeight = 0;

      while (edgeCount < n - 1) {
        let min = Infinity;
        let x = 0, y = 0;
        for (let i = 0; i < n; i++) {
          if (selected[i]) {
            for (let j = 0; j < n; j++) {
              if (!selected[j] && graph[i][j]) {
                if (min > graph[i][j]) {
                  min = graph[i][j];
                  x = i;
                  y = j;
                }
              }
            }
          }
        }
        mstWeight += graph[x][y];
        selected[y] = true;
        edgeCount++;
      }
      return mstWeight;
    }

    function calculateUpperBound(graph) {
      const n = graph.length;
      let maxTour = 0;
      for (let i = 0; i < n; i++) {
        let maxEdge = Math.max(...graph[i]);
        maxTour += maxEdge;
      }
      return maxTour;
    }

    function calculateTourLength(tour, graph) {
      let totalDistance = 0;
      const n = tour.length;
      for (let i = 0; i < n; i++) {
        totalDistance += graph[tour[i]][tour[(i + 1) % n]];
      }
      return totalDistance;
    }

    function calculateEfficiency(solutionPathLength, minimumPossiblePathLength, maximumPossiblePathLength) {
      return ((maximumPossiblePathLength - solutionPathLength) / (maximumPossiblePathLength - minimumPossiblePathLength)) * 100;
    }

    function drawLineSegment(container, start, end, color = "green", opacity = 1) {
      const length = Math.hypot(end.scaledY - start.scaledY, end.scaledX - start.scaledX);
      const deg = Math.atan2(end.scaledY - start.scaledY, end.scaledX - start.scaledX) * 180 / Math.PI;

      const newdiv = document.createElement('div');
      newdiv.style.width = length + "px";
      newdiv.style.height = "1px";
      newdiv.style.left = start.scaledX + "px";
      newdiv.style.top = start.scaledY + "px";
      newdiv.style.background = color;
      newdiv.style.opacity = opacity;
      newdiv.style.transformOrigin = "left 50%";
      newdiv.style.transform = "rotate(" + deg + "deg)";
      newdiv.style.position = "absolute";
      newdiv.style.pointerEvents = "none";

      container.appendChild(newdiv);
    }

    function displayPoints(container, points) {
      points.forEach(({ scaledX, scaledY }) => {
        const pointDiv = document.createElement('div');
        pointDiv.classList.add('point');
        pointDiv.style.left = `${scaledX - 3}px`;
        pointDiv.style.top = `${scaledY - 3}px`;
        container.appendChild(pointDiv);
      });
    }

    function visualizeTour(container, points, tour, color = "green") {
      for (let i = 0; i < tour.length; i++) {
        const start = points[tour[i]];
        const end = points[tour[(i + 1) % tour.length]];
        drawLineSegment(container, start, end, color);
      }
    }

    // Method implementations
    async function runAngularSort(container, points, graph, lowerBound, upperBound) {
      const startTime = performance.now();

      const sortedPoints = [...points].sort((a, b) => a.angle - b.angle);
      const tour = sortedPoints.map(p => p.id);
      const pathLength = calculateTourLength(tour, graph);

      visualizeTour(container, points, tour, "#007bff");

      const endTime = performance.now();
      const efficiency = calculateEfficiency(pathLength, lowerBound, upperBound);

      return {
        pathLength,
        efficiency,
        runtime: endTime - startTime,
        complexity: "O(n log n)",
        bestFor: "Quick approximate solutions"
      };
    }

    async function runZigzagOptimization(container, points, graph, lowerBound, upperBound) {
      const startTime = performance.now();

      const sortedPoints = [...points].sort((a, b) => a.angle - b.angle);
      const zigzag = (i) => {
        const p1 = sortedPoints[(i - 1) % sortedPoints.length];
        const p2 = sortedPoints[i % sortedPoints.length];
        const p3 = sortedPoints[(i + 1) % sortedPoints.length];
        const p4 = sortedPoints[(i + 2) % sortedPoints.length];
        const segment1 = distance(p1, p2);
        const segment3 = distance(p3, p4);
        const zigZagSegment1 = distance(p1, p3);
        const zigZagSegment3 = distance(p2, p4);
        return (zigZagSegment1 + zigZagSegment3) < (segment1 + segment3);
      };

      const tour = [];
      let i = 1;
      while (i < sortedPoints.length) {
        if (sortedPoints.length - i > 2 && zigzag(i)) {
          tour.push(sortedPoints[i - 1].id);
          tour.push(sortedPoints[(i + 1) % sortedPoints.length].id);
          tour.push(sortedPoints[i % sortedPoints.length].id);
          tour.push(sortedPoints[(i + 2) % sortedPoints.length].id);
          i += 3;
        } else {
          tour.push(sortedPoints[i - 1].id);
          tour.push(sortedPoints[i % sortedPoints.length].id);
          i++;
        }
      }

      // Remove duplicates while preserving order
      const uniqueTour = [...new Set(tour)];
      const pathLength = calculateTourLength(uniqueTour, graph);

      visualizeTour(container, points, uniqueTour, "#28a745");

      const endTime = performance.now();
      const efficiency = calculateEfficiency(pathLength, lowerBound, upperBound);

      return {
        pathLength,
        efficiency,
        runtime: endTime - startTime,
        complexity: "O(n log n)",
        bestFor: "Local optimization"
      };
    }

    async function run2OptOptimization(container, points, graph, lowerBound, upperBound) {
      const startTime = performance.now();

      // Nearest neighbor initial tour
      function nearestNeighborTour(points, graph) {
        const n = points.length;
        const visited = new Array(n).fill(false);
        const tour = [0];
        visited[0] = true;
        let current = 0;

        for (let step = 1; step < n; step++) {
          let nearest = -1;
          let minDist = Infinity;

          for (let j = 0; j < n; j++) {
            if (!visited[j] && graph[current][j] < minDist) {
              minDist = graph[current][j];
              nearest = j;
            }
          }

          tour.push(nearest);
          visited[nearest] = true;
          current = nearest;
        }

        return tour;
      }

      // 2-opt improvement
      function twoOptImprove(tour, graph, maxIterations = 100) {
        const n = tour.length;
        let improved = true;
        let iterations = 0;

        while (improved && iterations < maxIterations) {
          improved = false;
          iterations++;

          for (let i = 0; i < n - 1; i++) {
            for (let j = i + 2; j < n; j++) {
              if (j === n - 1 && i === 0) continue;

              const currentDistance = graph[tour[i]][tour[i + 1]] + graph[tour[j]][tour[(j + 1) % n]];
              const newDistance = graph[tour[i]][tour[j]] + graph[tour[i + 1]][tour[(j + 1) % n]];

              if (newDistance < currentDistance) {
                const newTour = [...tour];
                for (let k = 0; k <= j - i - 1; k++) {
                  newTour[i + 1 + k] = tour[j - k];
                }
                tour = newTour;
                improved = true;
              }
            }
          }
        }

        return tour;
      }

      let tour = nearestNeighborTour(points, graph);
      tour = twoOptImprove(tour, graph);
      const pathLength = calculateTourLength(tour, graph);

      visualizeTour(container, points, tour, "#dc3545");

      const endTime = performance.now();
      const efficiency = calculateEfficiency(pathLength, lowerBound, upperBound);

      return {
        pathLength,
        efficiency,
        runtime: endTime - startTime,
        complexity: "O(n²)",
        bestFor: "High-quality solutions"
      };
    }

    // Helper: 2-opt improvement function (shared by hybrid methods)
    function twoOptImproveShared(tour, graph, maxIterations = 100) {
      const n = tour.length;
      let improved = true;
      let iterations = 0;

      while (improved && iterations < maxIterations) {
        improved = false;
        iterations++;

        for (let i = 0; i < n - 1; i++) {
          for (let j = i + 2; j < n; j++) {
            if (j === n - 1 && i === 0) continue;

            const currentDistance = graph[tour[i]][tour[i + 1]] + graph[tour[j]][tour[(j + 1) % n]];
            const newDistance = graph[tour[i]][tour[j]] + graph[tour[i + 1]][tour[(j + 1) % n]];

            if (newDistance < currentDistance) {
              const newTour = [...tour];
              for (let k = 0; k <= j - i - 1; k++) {
                newTour[i + 1 + k] = tour[j - k];
              }
              tour = newTour;
              improved = true;
            }
          }
        }
      }

      return tour;
    }

    // Helper: Apply zigzag optimization on a tour
    function applyZigzagOnTour(tourIndices, points, graph) {
      // Convert tour indices to points in tour order
      const tourPoints = tourIndices.map(idx => ({ ...points[idx], originalId: idx }));

      const zigzag = (i, pts) => {
        const p1 = pts[(i - 1 + pts.length) % pts.length];
        const p2 = pts[i % pts.length];
        const p3 = pts[(i + 1) % pts.length];
        const p4 = pts[(i + 2) % pts.length];
        const segment1 = distance(p1, p2);
        const segment3 = distance(p3, p4);
        const zigZagSegment1 = distance(p1, p3);
        const zigZagSegment3 = distance(p2, p4);
        return (zigZagSegment1 + zigZagSegment3) < (segment1 + segment3);
      };

      const newTour = [];
      let i = 1;
      while (i < tourPoints.length) {
        if (tourPoints.length - i > 2 && zigzag(i, tourPoints)) {
          newTour.push(tourPoints[i - 1].originalId);
          newTour.push(tourPoints[(i + 1) % tourPoints.length].originalId);
          newTour.push(tourPoints[i % tourPoints.length].originalId);
          newTour.push(tourPoints[(i + 2) % tourPoints.length].originalId);
          i += 3;
        } else {
          newTour.push(tourPoints[i - 1].originalId);
          newTour.push(tourPoints[i % tourPoints.length].originalId);
          i++;
        }
      }

      // Remove duplicates while preserving order
      return [...new Set(newTour)];
    }

    // Method 4: Hybrid 2-Opt → Zigzag
    async function runHybrid2OptThenZigzag(container, points, graph, lowerBound, upperBound) {
      const startTime = performance.now();

      // Step 1: Nearest neighbor initial tour
      function nearestNeighborTour(points, graph) {
        const n = points.length;
        const visited = new Array(n).fill(false);
        const tour = [0];
        visited[0] = true;
        let current = 0;

        for (let step = 1; step < n; step++) {
          let nearest = -1;
          let minDist = Infinity;

          for (let j = 0; j < n; j++) {
            if (!visited[j] && graph[current][j] < minDist) {
              minDist = graph[current][j];
              nearest = j;
            }
          }

          tour.push(nearest);
          visited[nearest] = true;
          current = nearest;
        }

        return tour;
      }

      // Step 2: Apply 2-opt optimization first
      let tour = nearestNeighborTour(points, graph);
      tour = twoOptImproveShared(tour, graph);

      // Step 3: Apply zigzag refinement
      tour = applyZigzagOnTour(tour, points, graph);

      const pathLength = calculateTourLength(tour, graph);
      visualizeTour(container, points, tour, "#6f42c1");

      const endTime = performance.now();
      const efficiency = calculateEfficiency(pathLength, lowerBound, upperBound);

      return {
        pathLength,
        efficiency,
        runtime: endTime - startTime,
        complexity: "O(n²)",
        bestFor: "Global then local optimization"
      };
    }

    // Method 5: Hybrid Zigzag → 2-Opt
    async function runHybridZigzagThen2Opt(container, points, graph, lowerBound, upperBound) {
      const startTime = performance.now();

      // Step 1: Apply zigzag optimization on angular sorted points
      const sortedPoints = [...points].sort((a, b) => a.angle - b.angle);

      const zigzag = (i) => {
        const p1 = sortedPoints[(i - 1) % sortedPoints.length];
        const p2 = sortedPoints[i % sortedPoints.length];
        const p3 = sortedPoints[(i + 1) % sortedPoints.length];
        const p4 = sortedPoints[(i + 2) % sortedPoints.length];
        const segment1 = distance(p1, p2);
        const segment3 = distance(p3, p4);
        const zigZagSegment1 = distance(p1, p3);
        const zigZagSegment3 = distance(p2, p4);
        return (zigZagSegment1 + zigZagSegment3) < (segment1 + segment3);
      };

      let tour = [];
      let i = 1;
      while (i < sortedPoints.length) {
        if (sortedPoints.length - i > 2 && zigzag(i)) {
          tour.push(sortedPoints[i - 1].id);
          tour.push(sortedPoints[(i + 1) % sortedPoints.length].id);
          tour.push(sortedPoints[i % sortedPoints.length].id);
          tour.push(sortedPoints[(i + 2) % sortedPoints.length].id);
          i += 3;
        } else {
          tour.push(sortedPoints[i - 1].id);
          tour.push(sortedPoints[i % sortedPoints.length].id);
          i++;
        }
      }

      // Remove duplicates while preserving order
      tour = [...new Set(tour)];

      // Step 2: Apply 2-opt refinement
      tour = twoOptImproveShared(tour, graph);

      const pathLength = calculateTourLength(tour, graph);
      visualizeTour(container, points, tour, "#fd7e14");

      const endTime = performance.now();
      const efficiency = calculateEfficiency(pathLength, lowerBound, upperBound);

      return {
        pathLength,
        efficiency,
        runtime: endTime - startTime,
        complexity: "O(n²)",
        bestFor: "Local then global optimization"
      };
    }

    // Method 6: Sonar Visit - O(1) angle steps algorithm
    // Uses a 360° rotation sweep with fixed angle steps determined by grid size
    // Points on the same angle are connected by distance from center
    async function runSonarVisit(container, points, graph, lowerBound, upperBound) {
      const startTime = performance.now();

      // Calculate angle step based on grid size to ensure we visit all grid intersections
      // For an N×N grid, we need at most 4*N angle steps to cover all possible angles
      // This is O(1) with respect to point count - only depends on grid resolution
      const angleSteps = 4 * GRID_SIZE;
      const angleStep = (2 * Math.PI) / angleSteps;

      // Group points by their angle bucket
      const angleBuckets = new Map();

      points.forEach(point => {
        // Normalize angle to 0 to 2*PI
        let angle = point.angle;
        if (angle < 0) angle += 2 * Math.PI;

        // Find which bucket this point belongs to
        const bucketIndex = Math.floor(angle / angleStep);
        if (!angleBuckets.has(bucketIndex)) {
          angleBuckets.set(bucketIndex, []);
        }
        angleBuckets.get(bucketIndex).push(point);
      });

      // Sort points within each bucket by distance from center (outward sweep)
      const center = { x: 0.5, y: 0.5 };
      angleBuckets.forEach((bucketPoints, key) => {
        bucketPoints.sort((a, b) => {
          const distA = Math.hypot(a.x - center.x, a.y - center.y);
          const distB = Math.hypot(b.x - center.x, b.y - center.y);
          return distA - distB;
        });
      });

      // Build tour by sweeping through angle buckets in order
      const tour = [];
      for (let i = 0; i < angleSteps; i++) {
        if (angleBuckets.has(i)) {
          const bucketPoints = angleBuckets.get(i);
          bucketPoints.forEach(p => tour.push(p.id));
        }
      }

      const pathLength = calculateTourLength(tour, graph);
      visualizeTour(container, points, tour, "#17a2b8");

      const endTime = performance.now();
      const efficiency = calculateEfficiency(pathLength, lowerBound, upperBound);

      return {
        pathLength,
        efficiency,
        runtime: endTime - startTime,
        complexity: "O(1)*",
        bestFor: "Constant-time approximation"
      };
    }

    // Main execution
    async function runComparison() {
      const results = [];

      // Generate points for all canvases (6 methods now)
      const containers = [
        document.getElementById('canvas1'),
        document.getElementById('canvas2'),
        document.getElementById('canvas3'),
        document.getElementById('canvas4'),
        document.getElementById('canvas5'),
        document.getElementById('canvas6')
      ];

      // Generate normalized points once (same for all canvases)
      const normalizedPoints = generateNormalizedPoints(NUM_POINTS);

      containers.forEach(container => {
        // Get actual canvas size
        const canvasSize = container.offsetWidth || 250; // Fallback to 250 if not yet rendered

        // Scale points to current canvas size
        const points = scalePoints(normalizedPoints, canvasSize);
        displayPoints(container, points);
        container.points = points;
        container.normalizedPoints = normalizedPoints;
        container.canvasSize = canvasSize;
        container.graph = createDistanceMatrix(points);
        container.lowerBound = calculateMST(container.graph);
        container.upperBound = calculateUpperBound(container.graph);
      });

      // Run methods sequentially from 1 to 6
      const methods = [
        { name: "Angular Sort", fn: runAngularSort, id: 1 },
        { name: "Zigzag Optimization", fn: runZigzagOptimization, id: 2 },
        { name: "2-Opt Optimization", fn: run2OptOptimization, id: 3 },
        { name: "Hybrid: 2-Opt → Zigzag", fn: runHybrid2OptThenZigzag, id: 4 },
        { name: "Hybrid: Zigzag → 2-Opt", fn: runHybridZigzagThen2Opt, id: 5 },
        { name: "Sonar Visit", fn: runSonarVisit, id: 6 }
      ];

      // Execute methods sequentially (1 to 5)
      for (let i = 0; i < methods.length; i++) {
        const method = methods[i];
        const container = containers[i];

        document.getElementById(`progress${method.id}`).style.width = '50%';

        // Small delay between methods to visualize sequential execution
        await new Promise(resolve => setTimeout(resolve, 100));

        const result = await method.fn(
          container,
          container.points,
          container.graph,
          container.lowerBound,
          container.upperBound
        );

        result.name = method.name;
        results.push(result);

        document.getElementById(`progress${method.id}`).style.width = '100%';
        document.getElementById(`stats${method.id}`).innerHTML = `
          <div>Path Length: ${result.pathLength.toFixed(2)}</div>
          <div>Efficiency: ${result.efficiency.toFixed(1)}%</div>
          <div>Runtime: ${result.runtime.toFixed(1)}ms</div>
        `;
      }

      // Update comparison table
      const tbody = document.getElementById('results-tbody');
      tbody.innerHTML = '';

      const bestPath = Math.min(...results.map(r => r.pathLength));
      const bestEfficiency = Math.max(...results.map(r => r.efficiency));
      const bestRuntime = Math.min(...results.map(r => r.runtime));

      results.forEach(result => {
        const row = tbody.insertRow();
        row.innerHTML = `
          <td>${result.name}</td>
          <td class="${result.pathLength === bestPath ? 'best' : ''}">${result.pathLength.toFixed(2)}</td>
          <td class="${result.efficiency === bestEfficiency ? 'best' : ''}">${result.efficiency.toFixed(1)}%</td>
          <td class="${result.runtime === bestRuntime ? 'best' : ''}">${result.runtime.toFixed(1)}ms</td>
          <td>${result.complexity}</td>
          <td>${result.bestFor}</td>
        `;
      });
    }

    // Debounce function for resize handler
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // Re-render canvases on resize
    const handleResize = debounce(() => {
      // Clear all canvases and re-run
      const containers = [
        document.getElementById('canvas1'),
        document.getElementById('canvas2'),
        document.getElementById('canvas3'),
        document.getElementById('canvas4'),
        document.getElementById('canvas5'),
        document.getElementById('canvas6')
      ];

      containers.forEach(container => {
        container.innerHTML = '';
      });

      // Reset progress bars and stats
      for (let i = 1; i <= 6; i++) {
        document.getElementById(`progress${i}`).style.width = '0%';
        document.getElementById(`stats${i}`).innerHTML = 'Resizing...';
      }

      runComparison();
    }, 250);

    // Listen for resize events
    window.addEventListener('resize', handleResize);

    // Set grid info text
    document.getElementById('grid-info').textContent =
      `Points are placed on a virtual ${GRID_SIZE}×${GRID_SIZE} grid for consistent calculations.`;

    // Start comparison
    runComparison();
  </script>
</body>

</html>