<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Path Optimization Methods Comparison</title>
  <style>
    :root {
      font-size: 16px;
    }

    body {
      margin: 0;
      padding: 1.25rem;
      background: #f0f0f0;
      font-family: Arial, sans-serif;
    }

    .header {
      text-align: center;
      margin-bottom: 1.875rem;
    }

    .header-info {
      font-size: 0.75rem;
      color: #666;
      margin-top: 0.625rem;
    }

    .section-title {
      font-size: 1.25rem;
      font-weight: bold;
      color: #333;
      margin: 1.875rem 0 0.9375rem 0;
      padding: 0.625rem;
      background: #e9ecef;
      border-radius: 0.3125rem;
    }

    .methods-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(17.5rem, 1fr));
      gap: 1.25rem;
      margin-bottom: 1.875rem;
    }

    .method-card {
      background: white;
      border-radius: 0.625rem;
      padding: 1.25rem;
      box-shadow: 0 0.125rem 0.625rem rgba(0, 0, 0, 0.1);
    }

    .method-title {
      font-size: 1rem;
      font-weight: bold;
      margin-bottom: 0.625rem;
      color: #333;
    }

    .canvas-container {
      position: relative;
      width: 100%;
      padding-bottom: 100%; /* Maintain aspect ratio 1:1 */
      background: white;
      border: 0.0625rem solid #ccc;
      border-radius: 50%;
      margin: 0 auto 0.9375rem;
      box-sizing: border-box;
    }

    .canvas-inner {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .point {
      position: absolute;
      width: 0.375rem;
      height: 0.375rem;
      background: red;
      border-radius: 50%;
      transform: translate(-50%, -50%);
    }

    .line-segment {
      position: absolute;
      height: 0.0625rem;
      transform-origin: left center;
      pointer-events: none;
    }

    .stats {
      font-size: 0.75rem;
      background: #f8f9fa;
      padding: 0.625rem;
      border-radius: 0.3125rem;
      margin-top: 0.625rem;
    }

    .comparison-table {
      background: white;
      border-radius: 0.625rem;
      padding: 1.25rem;
      box-shadow: 0 0.125rem 0.625rem rgba(0, 0, 0, 0.1);
      overflow-x: auto;
    }

    table {
      width: 100%;
      border-collapse: collapse;
    }

    th, td {
      padding: 0.75rem;
      text-align: left;
      border-bottom: 0.0625rem solid #ddd;
    }

    th {
      background-color: #f8f9fa;
      font-weight: bold;
    }

    .best {
      background-color: #d4edda;
      font-weight: bold;
    }

    .progress {
      height: 0.25rem;
      background: #e9ecef;
      border-radius: 0.125rem;
      margin: 0.625rem 0;
      overflow: hidden;
    }

    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #28a745, #20c997);
      width: 0%;
      transition: width 0.3s ease;
    }

    .method-description {
      font-size: 0.8125rem;
      color: #666;
      margin-bottom: 0.9375rem;
      line-height: 1.4;
    }

    .section-divider {
      border-top: 0.125rem solid #dee2e6;
      margin: 1.25rem 0;
    }

    .complexity-notes {
      font-size: 0.75rem;
      color: #666;
      margin-top: 0.9375rem;
      padding: 0.625rem;
      background: #f8f9fa;
      border-radius: 0.3125rem;
    }

    /* Mobile responsiveness improvements */
    @media (max-width: 48rem) {
      body {
        padding: 0.75rem;
      }

      .methods-container {
        grid-template-columns: 1fr;
        gap: 1rem;
      }

      .method-card {
        padding: 1rem;
      }

      th, td {
        padding: 0.5rem;
        font-size: 0.875rem;
      }

      .comparison-table {
        padding: 0.75rem;
      }
    }

    @media (max-width: 30rem) {
      :root {
        font-size: 14px;
      }

      .header h1 {
        font-size: 1.5rem;
      }

      th, td {
        padding: 0.375rem;
        font-size: 0.75rem;
      }
    }
  </style>
</head>

<body>
  <div class="header">
    <h1>Path Optimization Methods Comparison</h1>
    <p>Comparing different approaches to solve the Traveling Salesman Problem</p>
    <p id="grid-info" class="header-info"></p>
  </div>

  <div class="section-title">Sonar Visit Based Algorithms (O(1) base)</div>
  <div class="methods-container">
    <div class="method-card">
      <div class="method-title">1. Sonar Visit</div>
      <div class="method-description">
        360° rotation sweep in fixed angle steps. Points on the same angle are connected by distance from center.
        O(1) angle steps regardless of point count.
      </div>
      <div class="canvas-container"><div class="canvas-inner" id="canvas1"></div></div>
      <div class="progress"><div class="progress-bar" id="progress1"></div></div>
      <div class="stats" id="stats1">Initializing...</div>
    </div>

    <div class="method-card">
      <div class="method-title">2. Sonar Visit → Zigzag</div>
      <div class="method-description">
        Sonar visit followed by zigzag local optimization.
        O(1) base + O(n) zigzag refinement.
      </div>
      <div class="canvas-container"><div class="canvas-inner" id="canvas2"></div></div>
      <div class="progress"><div class="progress-bar" id="progress2"></div></div>
      <div class="stats" id="stats2">Initializing...</div>
    </div>

    <div class="method-card">
      <div class="method-title">3. Sonar Visit → 2-Opt</div>
      <div class="method-description">
        Sonar visit followed by 2-opt edge swapping.
        O(1) base + O(n²) 2-opt refinement.
      </div>
      <div class="canvas-container"><div class="canvas-inner" id="canvas3"></div></div>
      <div class="progress"><div class="progress-bar" id="progress3"></div></div>
      <div class="stats" id="stats3">Initializing...</div>
    </div>

    <div class="method-card">
      <div class="method-title">4. Sonar Visit → Zigzag → 2-Opt</div>
      <div class="method-description">
        Sonar visit, then zigzag local optimization, then 2-opt refinement.
        Local improvements before global edge swapping.
      </div>
      <div class="canvas-container"><div class="canvas-inner" id="canvas4"></div></div>
      <div class="progress"><div class="progress-bar" id="progress4"></div></div>
      <div class="stats" id="stats4">Initializing...</div>
    </div>

    <div class="method-card">
      <div class="method-title">5. Sonar Visit → 2-Opt → Zigzag</div>
      <div class="method-description">
        Sonar visit, then 2-opt edge swapping, then zigzag refinement.
        Global edge swapping before local improvements.
      </div>
      <div class="canvas-container"><div class="canvas-inner" id="canvas5"></div></div>
      <div class="progress"><div class="progress-bar" id="progress5"></div></div>
      <div class="stats" id="stats5">Initializing...</div>
    </div>
  </div>

  <div class="section-divider"></div>

  <div class="section-title">Angular Sort Based Algorithms (O(n log n) base)</div>
  <div class="methods-container">
    <div class="method-card">
      <div class="method-title">6. Angular Sort</div>
      <div class="method-description">
        Sorts points by angle from center and connects them sequentially.
        Fast O(n log n) but often suboptimal.
      </div>
      <div class="canvas-container"><div class="canvas-inner" id="canvas6"></div></div>
      <div class="progress"><div class="progress-bar" id="progress6"></div></div>
      <div class="stats" id="stats6">Initializing...</div>
    </div>

    <div class="method-card">
      <div class="method-title">7. Angular Sort → Zigzag</div>
      <div class="method-description">
        Angular sort followed by zigzag local optimization.
        Checks if skipping intermediate points reduces path length.
      </div>
      <div class="canvas-container"><div class="canvas-inner" id="canvas7"></div></div>
      <div class="progress"><div class="progress-bar" id="progress7"></div></div>
      <div class="stats" id="stats7">Initializing...</div>
    </div>

    <div class="method-card">
      <div class="method-title">8. Angular Sort → 2-Opt</div>
      <div class="method-description">
        Angular sort followed by 2-opt edge swapping.
        Iteratively swaps edge pairs to improve the tour.
      </div>
      <div class="canvas-container"><div class="canvas-inner" id="canvas8"></div></div>
      <div class="progress"><div class="progress-bar" id="progress8"></div></div>
      <div class="stats" id="stats8">Initializing...</div>
    </div>

    <div class="method-card">
      <div class="method-title">9. Angular Sort → Zigzag → 2-Opt</div>
      <div class="method-description">
        Angular sort, then zigzag local optimization, then 2-opt refinement.
        Local improvements before global edge swapping.
      </div>
      <div class="canvas-container"><div class="canvas-inner" id="canvas9"></div></div>
      <div class="progress"><div class="progress-bar" id="progress9"></div></div>
      <div class="stats" id="stats9">Initializing...</div>
    </div>

    <div class="method-card">
      <div class="method-title">10. Angular Sort → 2-Opt → Zigzag</div>
      <div class="method-description">
        Angular sort, then 2-opt edge swapping, then zigzag refinement.
        Global edge swapping before local improvements.
      </div>
      <div class="canvas-container"><div class="canvas-inner" id="canvas10"></div></div>
      <div class="progress"><div class="progress-bar" id="progress10"></div></div>
      <div class="stats" id="stats10">Initializing...</div>
    </div>
  </div>

  <div class="comparison-table">
    <h2>Performance Comparison</h2>
    <table id="comparison-table">
      <thead>
        <tr>
          <th>Method</th>
          <th>Path Length</th>
          <th>Efficiency %</th>
          <th>Runtime (ms)</th>
          <th>Complexity</th>
          <th>Best For</th>
        </tr>
      </thead>
      <tbody id="results-tbody">
        <tr><td colspan="6">Running optimizations...</td></tr>
      </tbody>
    </table>
    <div class="complexity-notes">
      <strong>Complexity Notes:</strong><br>
      • <strong>Sonar Visit O(1)*</strong>: The angle sweep uses a fixed number of steps (4×GRID_SIZE) determined by grid resolution,
        not by point count. While point assignment to buckets is O(n), the core sweep algorithm is constant-time.
        With sufficient grid precision, all point configurations can be handled in constant angle steps.<br>
      • <strong>Angular Sort O(n log n)</strong>: Dominated by the sorting step<br>
      • <strong>Zigzag O(n)</strong>: Linear pass through sorted points<br>
      • <strong>2-Opt O(n²)</strong>: Nested loop checking all edge pairs
    </div>
  </div>

  <script>
    // Shared utilities
    function randomIntFromInterval(min, max) {
      return Math.floor(Math.random() * (max - min + 1) + min);
    }

    const NUM_POINTS = 50; // Fixed for fair comparison
    const GRID_SIZE = 40; // Virtual N×N grid for point placement (doubled for denser grid)

    // Generate same points for all methods with random seed for variety on each reload
    const initialSeed = Math.floor(Math.random() * 1000000);

    // Generate points on a virtual N×N grid for consistent placement
    // This enables O(1) sonar visit as angle steps are determined by grid size, not point count
    const generateNormalizedPoints = (numPoints, gridSize = GRID_SIZE, seed = initialSeed) => {
      // Simple LCG for reproducible results within same page load
      let currentSeed = seed;
      const rng = () => {
        currentSeed = (currentSeed * 1103515245 + 12345) % (2**31);
        return currentSeed / (2**31);
      };

      const center = 0.5; // Normalized center
      const maxRadius = 0.45; // Leave some padding from edges

      // Generate all valid grid positions within the circular area
      const gridStep = 1 / gridSize;
      const validPositions = [];

      for (let gx = 0; gx < gridSize; gx++) {
        for (let gy = 0; gy < gridSize; gy++) {
          const x = (gx + 0.5) * gridStep;
          const y = (gy + 0.5) * gridStep;
          const dx = x - center;
          const dy = y - center;
          const distFromCenter = Math.sqrt(dx * dx + dy * dy);

          // Only include points within the circular area
          if (distFromCenter <= maxRadius) {
            const angle = Math.atan2(dy, dx);
            validPositions.push({ x, y, angle: angle < 0 ? angle + 2 * Math.PI : angle, gx, gy });
          }
        }
      }

      // Shuffle valid positions using Fisher-Yates
      for (let i = validPositions.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [validPositions[i], validPositions[j]] = [validPositions[j], validPositions[i]];
      }

      // Select numPoints from shuffled positions
      const points = validPositions.slice(0, Math.min(numPoints, validPositions.length));

      // Assign IDs
      return points.map((p, idx) => ({ ...p, id: idx }));
    };

    // Scale normalized points to percentage values (0-100%)
    const scalePointsToPercent = (normalizedPoints) => {
      return normalizedPoints.map(p => ({
        ...p,
        percentX: p.x * 100,
        percentY: p.y * 100
      }));
    };

    // Distance using normalized coordinates for consistent calculations
    const distance = (start, end) => Math.hypot(end.y - start.y, end.x - start.x);

    function createDistanceMatrix(points) {
      const n = points.length;
      const graph = Array.from({ length: n }, () => Array(n).fill(0));
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          if (i !== j) {
            graph[i][j] = distance(points[i], points[j]);
          }
        }
      }
      return graph;
    }

    function calculateMST(graph) {
      const n = graph.length;
      const selected = new Array(n).fill(false);
      selected[0] = true;
      let edgeCount = 0;
      let mstWeight = 0;

      while (edgeCount < n - 1) {
        let min = Infinity;
        let x = 0, y = 0;
        for (let i = 0; i < n; i++) {
          if (selected[i]) {
            for (let j = 0; j < n; j++) {
              if (!selected[j] && graph[i][j]) {
                if (min > graph[i][j]) {
                  min = graph[i][j];
                  x = i;
                  y = j;
                }
              }
            }
          }
        }
        mstWeight += graph[x][y];
        selected[y] = true;
        edgeCount++;
      }
      return mstWeight;
    }

    function calculateUpperBound(graph) {
      const n = graph.length;
      let maxTour = 0;
      for (let i = 0; i < n; i++) {
        let maxEdge = Math.max(...graph[i]);
        maxTour += maxEdge;
      }
      return maxTour;
    }

    function calculateTourLength(tour, graph) {
      let totalDistance = 0;
      const n = tour.length;
      for (let i = 0; i < n; i++) {
        totalDistance += graph[tour[i]][tour[(i + 1) % n]];
      }
      return totalDistance;
    }

    function calculateEfficiency(solutionPathLength, minimumPossiblePathLength, maximumPossiblePathLength) {
      return ((maximumPossiblePathLength - solutionPathLength) / (maximumPossiblePathLength - minimumPossiblePathLength)) * 100;
    }

    // Draw line segment using percentage-based positioning
    function drawLineSegment(container, start, end, color = "green", opacity = 1) {
      // Calculate length and angle in percentage space
      const dx = end.percentX - start.percentX;
      const dy = end.percentY - start.percentY;
      const length = Math.hypot(dx, dy);
      const deg = Math.atan2(dy, dx) * 180 / Math.PI;

      const newdiv = document.createElement('div');
      newdiv.className = 'line-segment';
      newdiv.style.width = length + "%";
      newdiv.style.left = start.percentX + "%";
      newdiv.style.top = start.percentY + "%";
      newdiv.style.background = color;
      newdiv.style.opacity = opacity;
      newdiv.style.transform = "rotate(" + deg + "deg)";

      container.appendChild(newdiv);
    }

    function displayPoints(container, points) {
      points.forEach(({ percentX, percentY }) => {
        const pointDiv = document.createElement('div');
        pointDiv.classList.add('point');
        pointDiv.style.left = percentX + "%";
        pointDiv.style.top = percentY + "%";
        container.appendChild(pointDiv);
      });
    }

    function visualizeTour(container, points, tour, color = "green") {
      for (let i = 0; i < tour.length; i++) {
        const start = points[tour[i]];
        const end = points[tour[(i + 1) % tour.length]];
        drawLineSegment(container, start, end, color);
      }
    }

    // ========================================
    // Shared optimization functions
    // ========================================

    // 2-opt improvement function
    function twoOptImprove(tour, graph, maxIterations = 100) {
      const n = tour.length;
      let improved = true;
      let iterations = 0;

      while (improved && iterations < maxIterations) {
        improved = false;
        iterations++;

        for (let i = 0; i < n - 1; i++) {
          for (let j = i + 2; j < n; j++) {
            if (j === n - 1 && i === 0) continue;

            const currentDistance = graph[tour[i]][tour[i + 1]] + graph[tour[j]][tour[(j + 1) % n]];
            const newDistance = graph[tour[i]][tour[j]] + graph[tour[i + 1]][tour[(j + 1) % n]];

            if (newDistance < currentDistance) {
              const newTour = [...tour];
              for (let k = 0; k <= j - i - 1; k++) {
                newTour[i + 1 + k] = tour[j - k];
              }
              tour = newTour;
              improved = true;
            }
          }
        }
      }

      return tour;
    }

    // Apply zigzag optimization on a tour (given as array of point IDs)
    function applyZigzagOnTour(tourIndices, points, graph) {
      // Convert tour indices to points in tour order
      const tourPoints = tourIndices.map(idx => ({ ...points[idx], originalId: idx }));

      const zigzag = (i, pts) => {
        const p1 = pts[(i - 1 + pts.length) % pts.length];
        const p2 = pts[i % pts.length];
        const p3 = pts[(i + 1) % pts.length];
        const p4 = pts[(i + 2) % pts.length];
        const segment1 = distance(p1, p2);
        const segment3 = distance(p3, p4);
        const zigZagSegment1 = distance(p1, p3);
        const zigZagSegment3 = distance(p2, p4);
        return (zigZagSegment1 + zigZagSegment3) < (segment1 + segment3);
      };

      const newTour = [];
      let i = 1;
      while (i < tourPoints.length) {
        if (tourPoints.length - i > 2 && zigzag(i, tourPoints)) {
          newTour.push(tourPoints[i - 1].originalId);
          newTour.push(tourPoints[(i + 1) % tourPoints.length].originalId);
          newTour.push(tourPoints[i % tourPoints.length].originalId);
          newTour.push(tourPoints[(i + 2) % tourPoints.length].originalId);
          i += 3;
        } else {
          newTour.push(tourPoints[i - 1].originalId);
          newTour.push(tourPoints[i % tourPoints.length].originalId);
          i++;
        }
      }

      // Remove duplicates while preserving order
      return [...new Set(newTour)];
    }

    // ========================================
    // Sonar Visit based methods (1-5)
    // ========================================

    // Generate Sonar Visit tour (O(1) angle steps)
    function generateSonarVisitTour(points) {
      // Calculate angle step based on grid size
      const angleSteps = 4 * GRID_SIZE;
      const angleStep = (2 * Math.PI) / angleSteps;

      // Group points by their angle bucket
      const angleBuckets = new Map();

      points.forEach(point => {
        let angle = point.angle;
        if (angle < 0) angle += 2 * Math.PI;

        const bucketIndex = Math.floor(angle / angleStep);
        if (!angleBuckets.has(bucketIndex)) {
          angleBuckets.set(bucketIndex, []);
        }
        angleBuckets.get(bucketIndex).push(point);
      });

      // Sort points within each bucket by distance from center
      const center = { x: 0.5, y: 0.5 };
      angleBuckets.forEach((bucketPoints, key) => {
        bucketPoints.sort((a, b) => {
          const distA = Math.hypot(a.x - center.x, a.y - center.y);
          const distB = Math.hypot(b.x - center.x, b.y - center.y);
          return distA - distB;
        });
      });

      // Build tour by sweeping through angle buckets in order
      const tour = [];
      for (let i = 0; i < angleSteps; i++) {
        if (angleBuckets.has(i)) {
          const bucketPoints = angleBuckets.get(i);
          bucketPoints.forEach(p => tour.push(p.id));
        }
      }

      return tour;
    }

    // Method 1: Sonar Visit (base)
    async function runSonarVisit(container, points, graph, lowerBound, upperBound) {
      const startTime = performance.now();
      const tour = generateSonarVisitTour(points);
      const pathLength = calculateTourLength(tour, graph);
      visualizeTour(container, points, tour, "#17a2b8");
      const endTime = performance.now();
      const efficiency = calculateEfficiency(pathLength, lowerBound, upperBound);

      return {
        pathLength,
        efficiency,
        runtime: endTime - startTime,
        complexity: "O(1)*",
        bestFor: "Constant-time approximation"
      };
    }

    // Method 2: Sonar Visit → Zigzag
    async function runSonarVisitZigzag(container, points, graph, lowerBound, upperBound) {
      const startTime = performance.now();
      let tour = generateSonarVisitTour(points);
      tour = applyZigzagOnTour(tour, points, graph);
      const pathLength = calculateTourLength(tour, graph);
      visualizeTour(container, points, tour, "#20c997");
      const endTime = performance.now();
      const efficiency = calculateEfficiency(pathLength, lowerBound, upperBound);

      return {
        pathLength,
        efficiency,
        runtime: endTime - startTime,
        complexity: "O(n)",
        bestFor: "Fast local optimization"
      };
    }

    // Method 3: Sonar Visit → 2-Opt
    async function runSonarVisit2Opt(container, points, graph, lowerBound, upperBound) {
      const startTime = performance.now();
      let tour = generateSonarVisitTour(points);
      tour = twoOptImprove(tour, graph);
      const pathLength = calculateTourLength(tour, graph);
      visualizeTour(container, points, tour, "#007bff");
      const endTime = performance.now();
      const efficiency = calculateEfficiency(pathLength, lowerBound, upperBound);

      return {
        pathLength,
        efficiency,
        runtime: endTime - startTime,
        complexity: "O(n²)",
        bestFor: "High-quality from O(1) base"
      };
    }

    // Method 4: Sonar Visit → Zigzag → 2-Opt
    async function runSonarVisitZigzag2Opt(container, points, graph, lowerBound, upperBound) {
      const startTime = performance.now();
      let tour = generateSonarVisitTour(points);
      tour = applyZigzagOnTour(tour, points, graph);
      tour = twoOptImprove(tour, graph);
      const pathLength = calculateTourLength(tour, graph);
      visualizeTour(container, points, tour, "#6f42c1");
      const endTime = performance.now();
      const efficiency = calculateEfficiency(pathLength, lowerBound, upperBound);

      return {
        pathLength,
        efficiency,
        runtime: endTime - startTime,
        complexity: "O(n²)",
        bestFor: "Local then global optimization"
      };
    }

    // Method 5: Sonar Visit → 2-Opt → Zigzag
    async function runSonarVisit2OptZigzag(container, points, graph, lowerBound, upperBound) {
      const startTime = performance.now();
      let tour = generateSonarVisitTour(points);
      tour = twoOptImprove(tour, graph);
      tour = applyZigzagOnTour(tour, points, graph);
      const pathLength = calculateTourLength(tour, graph);
      visualizeTour(container, points, tour, "#e83e8c");
      const endTime = performance.now();
      const efficiency = calculateEfficiency(pathLength, lowerBound, upperBound);

      return {
        pathLength,
        efficiency,
        runtime: endTime - startTime,
        complexity: "O(n²)",
        bestFor: "Global then local optimization"
      };
    }

    // ========================================
    // Angular Sort based methods (6-10)
    // ========================================

    // Generate Angular Sort tour
    function generateAngularSortTour(points) {
      const sortedPoints = [...points].sort((a, b) => a.angle - b.angle);
      return sortedPoints.map(p => p.id);
    }

    // Method 6: Angular Sort (base)
    async function runAngularSort(container, points, graph, lowerBound, upperBound) {
      const startTime = performance.now();
      const tour = generateAngularSortTour(points);
      const pathLength = calculateTourLength(tour, graph);
      visualizeTour(container, points, tour, "#fd7e14");
      const endTime = performance.now();
      const efficiency = calculateEfficiency(pathLength, lowerBound, upperBound);

      return {
        pathLength,
        efficiency,
        runtime: endTime - startTime,
        complexity: "O(n log n)",
        bestFor: "Quick approximate solutions"
      };
    }

    // Method 7: Angular Sort → Zigzag
    async function runAngularSortZigzag(container, points, graph, lowerBound, upperBound) {
      const startTime = performance.now();
      let tour = generateAngularSortTour(points);
      tour = applyZigzagOnTour(tour, points, graph);
      const pathLength = calculateTourLength(tour, graph);
      visualizeTour(container, points, tour, "#28a745");
      const endTime = performance.now();
      const efficiency = calculateEfficiency(pathLength, lowerBound, upperBound);

      return {
        pathLength,
        efficiency,
        runtime: endTime - startTime,
        complexity: "O(n log n)",
        bestFor: "Local optimization"
      };
    }

    // Method 8: Angular Sort → 2-Opt
    async function runAngularSort2Opt(container, points, graph, lowerBound, upperBound) {
      const startTime = performance.now();
      let tour = generateAngularSortTour(points);
      tour = twoOptImprove(tour, graph);
      const pathLength = calculateTourLength(tour, graph);
      visualizeTour(container, points, tour, "#dc3545");
      const endTime = performance.now();
      const efficiency = calculateEfficiency(pathLength, lowerBound, upperBound);

      return {
        pathLength,
        efficiency,
        runtime: endTime - startTime,
        complexity: "O(n²)",
        bestFor: "High-quality solutions"
      };
    }

    // Method 9: Angular Sort → Zigzag → 2-Opt
    async function runAngularSortZigzag2Opt(container, points, graph, lowerBound, upperBound) {
      const startTime = performance.now();
      let tour = generateAngularSortTour(points);
      tour = applyZigzagOnTour(tour, points, graph);
      tour = twoOptImprove(tour, graph);
      const pathLength = calculateTourLength(tour, graph);
      visualizeTour(container, points, tour, "#6610f2");
      const endTime = performance.now();
      const efficiency = calculateEfficiency(pathLength, lowerBound, upperBound);

      return {
        pathLength,
        efficiency,
        runtime: endTime - startTime,
        complexity: "O(n²)",
        bestFor: "Local then global optimization"
      };
    }

    // Method 10: Angular Sort → 2-Opt → Zigzag
    async function runAngularSort2OptZigzag(container, points, graph, lowerBound, upperBound) {
      const startTime = performance.now();
      let tour = generateAngularSortTour(points);
      tour = twoOptImprove(tour, graph);
      tour = applyZigzagOnTour(tour, points, graph);
      const pathLength = calculateTourLength(tour, graph);
      visualizeTour(container, points, tour, "#795548");
      const endTime = performance.now();
      const efficiency = calculateEfficiency(pathLength, lowerBound, upperBound);

      return {
        pathLength,
        efficiency,
        runtime: endTime - startTime,
        complexity: "O(n²)",
        bestFor: "Global then local optimization"
      };
    }

    // Main execution
    async function runComparison() {
      const results = [];
      const numMethods = 10;

      // Generate containers for all methods
      const containers = [];
      for (let i = 1; i <= numMethods; i++) {
        containers.push(document.getElementById(`canvas${i}`));
      }

      // Generate normalized points once (same for all canvases)
      const normalizedPoints = generateNormalizedPoints(NUM_POINTS);

      // Scale points to percentage values
      const points = scalePointsToPercent(normalizedPoints);
      const graph = createDistanceMatrix(points);
      const lowerBound = calculateMST(graph);
      const upperBound = calculateUpperBound(graph);

      containers.forEach(container => {
        displayPoints(container, points);
        container.points = points;
        container.graph = graph;
        container.lowerBound = lowerBound;
        container.upperBound = upperBound;
      });

      // Define all methods in order
      const methods = [
        // Sonar Visit based (1-5)
        { name: "Sonar Visit", fn: runSonarVisit, id: 1 },
        { name: "Sonar Visit → Zigzag", fn: runSonarVisitZigzag, id: 2 },
        { name: "Sonar Visit → 2-Opt", fn: runSonarVisit2Opt, id: 3 },
        { name: "Sonar Visit → Zigzag → 2-Opt", fn: runSonarVisitZigzag2Opt, id: 4 },
        { name: "Sonar Visit → 2-Opt → Zigzag", fn: runSonarVisit2OptZigzag, id: 5 },
        // Angular Sort based (6-10)
        { name: "Angular Sort", fn: runAngularSort, id: 6 },
        { name: "Angular Sort → Zigzag", fn: runAngularSortZigzag, id: 7 },
        { name: "Angular Sort → 2-Opt", fn: runAngularSort2Opt, id: 8 },
        { name: "Angular Sort → Zigzag → 2-Opt", fn: runAngularSortZigzag2Opt, id: 9 },
        { name: "Angular Sort → 2-Opt → Zigzag", fn: runAngularSort2OptZigzag, id: 10 }
      ];

      // Execute methods sequentially
      for (let i = 0; i < methods.length; i++) {
        const method = methods[i];
        const container = containers[i];

        document.getElementById(`progress${method.id}`).style.width = '50%';

        // Small delay between methods to visualize sequential execution
        await new Promise(resolve => setTimeout(resolve, 50));

        const result = await method.fn(
          container,
          container.points,
          container.graph,
          container.lowerBound,
          container.upperBound
        );

        result.name = method.name;
        results.push(result);

        document.getElementById(`progress${method.id}`).style.width = '100%';
        document.getElementById(`stats${method.id}`).innerHTML = `
          <div>Path Length: ${result.pathLength.toFixed(2)}</div>
          <div>Efficiency: ${result.efficiency.toFixed(1)}%</div>
          <div>Runtime: ${result.runtime.toFixed(1)}ms</div>
        `;
      }

      // Update comparison table
      const tbody = document.getElementById('results-tbody');
      tbody.innerHTML = '';

      const bestPath = Math.min(...results.map(r => r.pathLength));
      const bestEfficiency = Math.max(...results.map(r => r.efficiency));
      const bestRuntime = Math.min(...results.map(r => r.runtime));

      results.forEach(result => {
        const row = tbody.insertRow();
        row.innerHTML = `
          <td>${result.name}</td>
          <td class="${result.pathLength === bestPath ? 'best' : ''}">${result.pathLength.toFixed(2)}</td>
          <td class="${result.efficiency === bestEfficiency ? 'best' : ''}">${result.efficiency.toFixed(1)}%</td>
          <td class="${result.runtime === bestRuntime ? 'best' : ''}">${result.runtime.toFixed(1)}ms</td>
          <td>${result.complexity}</td>
          <td>${result.bestFor}</td>
        `;
      });
    }

    // Debounce function for resize handler
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // Re-render canvases on resize
    const handleResize = debounce(() => {
      const numMethods = 10;
      const containers = [];
      for (let i = 1; i <= numMethods; i++) {
        const container = document.getElementById(`canvas${i}`);
        container.innerHTML = '';
        containers.push(container);
      }

      // Reset progress bars and stats
      for (let i = 1; i <= numMethods; i++) {
        document.getElementById(`progress${i}`).style.width = '0%';
        document.getElementById(`stats${i}`).innerHTML = 'Resizing...';
      }

      runComparison();
    }, 250);

    // Listen for resize events
    window.addEventListener('resize', handleResize);

    // Set grid info text
    document.getElementById('grid-info').textContent =
      `Points are placed on a virtual ${GRID_SIZE}×${GRID_SIZE} grid for consistent calculations.`;

    // Start comparison
    runComparison();
  </script>
</body>

</html>
