<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Path Optimization Methods Comparison</title>
  <!-- Algorithm modules - loaded from ./algorithms folder -->
  <script src="algorithms/utils.js"></script>
  <script src="algorithms/two-opt.js"></script>
  <script src="algorithms/zigzag.js"></script>
  <script src="algorithms/sonar-visit.js"></script>
  <script src="algorithms/angular-sort.js"></script>
  <script src="algorithms/nearest-neighbor.js"></script>
  <script src="algorithms/greedy-edge.js"></script>
  <script src="algorithms/simulated-annealing.js"></script>
  <script src="algorithms/genetic.js"></script>
  <script src="algorithms/brute-force.js"></script>
  <style>
    :root {
      font-size: 16px;
    }

    body {
      margin: 0;
      padding: 1.25rem;
      background: #f0f0f0;
      font-family: Arial, sans-serif;
    }

    .header {
      text-align: center;
      margin-bottom: 1.875rem;
    }

    .header-info {
      font-size: 0.75rem;
      color: #666;
      margin-top: 0.625rem;
    }

    .header-info a {
      color: #007bff;
      text-decoration: none;
    }

    .header-info a:hover {
      text-decoration: underline;
    }

    .section-title {
      font-size: 1.25rem;
      font-weight: bold;
      color: #333;
      margin: 1.875rem 0 0.9375rem 0;
      padding: 0.625rem;
      background: #e9ecef;
      border-radius: 0.3125rem;
    }

    .methods-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(17.5rem, 1fr));
      gap: 1.25rem;
      margin-bottom: 1.875rem;
    }

    .method-card {
      background: white;
      border-radius: 0.625rem;
      padding: 1.25rem;
      box-shadow: 0 0.125rem 0.625rem rgba(0, 0, 0, 0.1);
    }

    .method-title {
      font-size: 1rem;
      font-weight: bold;
      margin-bottom: 0.625rem;
      color: #333;
    }

    .canvas-container {
      position: relative;
      width: 100%;
      padding-bottom: 100%;
      background: white;
      border: 0.0625rem solid #ccc;
      border-radius: 50%;
      margin: 0 auto 0.9375rem;
      box-sizing: border-box;
    }

    .canvas-inner {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .point {
      position: absolute;
      width: 0.375rem;
      height: 0.375rem;
      background: red;
      border-radius: 50%;
      transform: translate(-50%, -50%);
    }

    .line-segment {
      position: absolute;
      height: 0.0625rem;
      transform-origin: left center;
      pointer-events: none;
    }

    .stats {
      font-size: 0.75rem;
      background: #f8f9fa;
      padding: 0.625rem;
      border-radius: 0.3125rem;
      margin-top: 0.625rem;
    }

    .comparison-table {
      background: white;
      border-radius: 0.625rem;
      padding: 1.25rem;
      box-shadow: 0 0.125rem 0.625rem rgba(0, 0, 0, 0.1);
      overflow-x: auto;
    }

    table {
      width: 100%;
      border-collapse: collapse;
    }

    th, td {
      padding: 0.75rem;
      text-align: left;
      border-bottom: 0.0625rem solid #ddd;
    }

    th {
      background-color: #f8f9fa;
      font-weight: bold;
    }

    .best {
      background-color: #d4edda;
      font-weight: bold;
    }

    .progress {
      height: 0.25rem;
      background: #e9ecef;
      border-radius: 0.125rem;
      margin: 0.625rem 0;
      overflow: hidden;
    }

    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #28a745, #20c997);
      width: 0%;
      transition: width 0.3s ease;
    }

    .method-description {
      font-size: 0.8125rem;
      color: #666;
      margin-bottom: 0.9375rem;
      line-height: 1.4;
    }

    .section-divider {
      border-top: 0.125rem solid #dee2e6;
      margin: 1.25rem 0;
    }

    .complexity-notes {
      font-size: 0.75rem;
      color: #666;
      margin-top: 0.9375rem;
      padding: 0.625rem;
      background: #f8f9fa;
      border-radius: 0.3125rem;
    }

    @media (max-width: 48rem) {
      body {
        padding: 0.75rem;
      }

      .methods-container {
        grid-template-columns: 1fr;
        gap: 1rem;
      }

      .method-card {
        padding: 1rem;
      }

      th, td {
        padding: 0.5rem;
        font-size: 0.875rem;
      }

      .comparison-table {
        padding: 0.75rem;
      }
    }

    @media (max-width: 30rem) {
      :root {
        font-size: 14px;
      }

      .header h1 {
        font-size: 1.5rem;
      }

      th, td {
        padding: 0.375rem;
        font-size: 0.75rem;
      }
    }
  </style>
</head>

<body>
  <div class="header">
    <h1>Path Optimization Methods Comparison</h1>
    <p>Comparing different approaches to solve the Traveling Salesman Problem</p>
    <p id="grid-info" class="header-info"></p>
    <p class="header-info">
      <a href="https://github.com/konard/sonar" target="_blank" rel="noopener noreferrer">View source code on GitHub</a>
    </p>
  </div>

  <div class="section-title">Sonar Visit Based Algorithms (O(1) base)</div>
  <div class="methods-container">
    <div class="method-card">
      <div class="method-title">1. Sonar Visit</div>
      <div class="method-description">
        360 degree rotation sweep in fixed angle steps. Points on the same angle are connected by distance from center.
        O(1) angle steps regardless of point count.
      </div>
      <div class="canvas-container"><div class="canvas-inner" id="canvas1"></div></div>
      <div class="progress"><div class="progress-bar" id="progress1"></div></div>
      <div class="stats" id="stats1">Initializing...</div>
    </div>

    <div class="method-card">
      <div class="method-title">2. Sonar Visit + Zigzag</div>
      <div class="method-description">
        Sonar visit followed by zigzag local optimization.
        O(1) base + O(n) zigzag refinement.
      </div>
      <div class="canvas-container"><div class="canvas-inner" id="canvas2"></div></div>
      <div class="progress"><div class="progress-bar" id="progress2"></div></div>
      <div class="stats" id="stats2">Initializing...</div>
    </div>

    <div class="method-card">
      <div class="method-title">3. Sonar Visit + 2-Opt</div>
      <div class="method-description">
        Sonar visit followed by 2-opt edge swapping.
        O(1) base + O(n squared) 2-opt refinement.
      </div>
      <div class="canvas-container"><div class="canvas-inner" id="canvas3"></div></div>
      <div class="progress"><div class="progress-bar" id="progress3"></div></div>
      <div class="stats" id="stats3">Initializing...</div>
    </div>

    <div class="method-card">
      <div class="method-title">4. Sonar Visit + Zigzag + 2-Opt</div>
      <div class="method-description">
        Sonar visit, then zigzag local optimization, then 2-opt refinement.
        Local improvements before global edge swapping.
      </div>
      <div class="canvas-container"><div class="canvas-inner" id="canvas4"></div></div>
      <div class="progress"><div class="progress-bar" id="progress4"></div></div>
      <div class="stats" id="stats4">Initializing...</div>
    </div>

    <div class="method-card">
      <div class="method-title">5. Sonar Visit + 2-Opt + Zigzag</div>
      <div class="method-description">
        Sonar visit, then 2-opt edge swapping, then zigzag refinement.
        Global edge swapping before local improvements.
      </div>
      <div class="canvas-container"><div class="canvas-inner" id="canvas5"></div></div>
      <div class="progress"><div class="progress-bar" id="progress5"></div></div>
      <div class="stats" id="stats5">Initializing...</div>
    </div>
  </div>

  <div class="section-divider"></div>

  <div class="section-title">Angular Sort Based Algorithms (O(n log n) base)</div>
  <div class="methods-container">
    <div class="method-card">
      <div class="method-title">6. Angular Sort</div>
      <div class="method-description">
        Sorts points by angle from center and connects them sequentially.
        Fast O(n log n) but often suboptimal.
      </div>
      <div class="canvas-container"><div class="canvas-inner" id="canvas6"></div></div>
      <div class="progress"><div class="progress-bar" id="progress6"></div></div>
      <div class="stats" id="stats6">Initializing...</div>
    </div>

    <div class="method-card">
      <div class="method-title">7. Angular Sort + Zigzag</div>
      <div class="method-description">
        Angular sort followed by zigzag local optimization.
        Checks if skipping intermediate points reduces path length.
      </div>
      <div class="canvas-container"><div class="canvas-inner" id="canvas7"></div></div>
      <div class="progress"><div class="progress-bar" id="progress7"></div></div>
      <div class="stats" id="stats7">Initializing...</div>
    </div>

    <div class="method-card">
      <div class="method-title">8. Angular Sort + 2-Opt</div>
      <div class="method-description">
        Angular sort followed by 2-opt edge swapping.
        Iteratively swaps edge pairs to improve the tour.
      </div>
      <div class="canvas-container"><div class="canvas-inner" id="canvas8"></div></div>
      <div class="progress"><div class="progress-bar" id="progress8"></div></div>
      <div class="stats" id="stats8">Initializing...</div>
    </div>

    <div class="method-card">
      <div class="method-title">9. Angular Sort + Zigzag + 2-Opt</div>
      <div class="method-description">
        Angular sort, then zigzag local optimization, then 2-opt refinement.
        Local improvements before global edge swapping.
      </div>
      <div class="canvas-container"><div class="canvas-inner" id="canvas9"></div></div>
      <div class="progress"><div class="progress-bar" id="progress9"></div></div>
      <div class="stats" id="stats9">Initializing...</div>
    </div>

    <div class="method-card">
      <div class="method-title">10. Angular Sort + 2-Opt + Zigzag</div>
      <div class="method-description">
        Angular sort, then 2-opt edge swapping, then zigzag refinement.
        Global edge swapping before local improvements.
      </div>
      <div class="canvas-container"><div class="canvas-inner" id="canvas10"></div></div>
      <div class="progress"><div class="progress-bar" id="progress10"></div></div>
      <div class="stats" id="stats10">Initializing...</div>
    </div>
  </div>

  <div class="section-divider"></div>

  <div class="section-title">Classic TSP Algorithms</div>
  <div class="methods-container">
    <div class="method-card">
      <div class="method-title">11. Nearest Neighbor</div>
      <div class="method-description">
        Greedy heuristic: start from a random point and always visit the closest unvisited point.
        Fast O(n squared) but can produce suboptimal tours.
      </div>
      <div class="canvas-container"><div class="canvas-inner" id="canvas11"></div></div>
      <div class="progress"><div class="progress-bar" id="progress11"></div></div>
      <div class="stats" id="stats11">Initializing...</div>
    </div>

    <div class="method-card">
      <div class="method-title">12. Greedy (Nearest Edge)</div>
      <div class="method-description">
        Builds tour by repeatedly adding the shortest edge that does not create a cycle or degree greater than 2.
        O(n squared log n) with good average performance.
      </div>
      <div class="canvas-container"><div class="canvas-inner" id="canvas12"></div></div>
      <div class="progress"><div class="progress-bar" id="progress12"></div></div>
      <div class="stats" id="stats12">Initializing...</div>
    </div>

    <div class="method-card">
      <div class="method-title">13. Simulated Annealing</div>
      <div class="method-description">
        Metaheuristic inspired by metal annealing. Accepts worse solutions with decreasing probability to escape local minima.
        Good for finding near-optimal solutions.
      </div>
      <div class="canvas-container"><div class="canvas-inner" id="canvas13"></div></div>
      <div class="progress"><div class="progress-bar" id="progress13"></div></div>
      <div class="stats" id="stats13">Initializing...</div>
    </div>

    <div class="method-card">
      <div class="method-title">14. Genetic Algorithm</div>
      <div class="method-description">
        Evolutionary approach using selection, crossover, and mutation on a population of tours.
        Effective for large instances where exact solutions are impractical.
      </div>
      <div class="canvas-container"><div class="canvas-inner" id="canvas14"></div></div>
      <div class="progress"><div class="progress-bar" id="progress14"></div></div>
      <div class="stats" id="stats14">Initializing...</div>
    </div>

    <div class="method-card">
      <div class="method-title">15. Brute Force (Optimal)</div>
      <div class="method-description">
        Exhaustive search through all permutations to find the optimal tour.
        O(n!) complexity - only feasible for small n. Used as reference for efficiency calculation.
      </div>
      <div class="canvas-container"><div class="canvas-inner" id="canvas15"></div></div>
      <div class="progress"><div class="progress-bar" id="progress15"></div></div>
      <div class="stats" id="stats15">Initializing...</div>
    </div>
  </div>

  <div class="comparison-table">
    <h2>Performance Comparison</h2>
    <table id="comparison-table">
      <thead>
        <tr>
          <th>Method</th>
          <th>Path Length</th>
          <th>Efficiency %</th>
          <th>Runtime (ms)</th>
          <th>Complexity</th>
          <th>Best For</th>
        </tr>
      </thead>
      <tbody id="results-tbody">
        <tr><td colspan="6">Running optimizations...</td></tr>
      </tbody>
    </table>
    <div class="complexity-notes">
      <strong>Complexity Notes:</strong><br>
      <strong>Sonar Visit O(1)*</strong>: The angle sweep uses a fixed number of steps (4 times GRID_SIZE) determined by grid resolution,
        not by point count. While point assignment to buckets is O(n), the core sweep algorithm is constant-time.
        With sufficient grid precision, all point configurations can be handled in constant angle steps.<br>
      <strong>Angular Sort O(n log n)</strong>: Dominated by the sorting step<br>
      <strong>Zigzag O(n)</strong>: Linear pass through sorted points<br>
      <strong>2-Opt O(n squared)</strong>: Nested loop checking all edge pairs<br>
      <strong>Nearest Neighbor O(n squared)</strong>: Greedy selection of closest unvisited city<br>
      <strong>Greedy Edge O(n squared log n)</strong>: Sort all edges, then greedy selection avoiding cycles<br>
      <strong>Simulated Annealing O(n times iterations)</strong>: Probabilistic optimization with cooling schedule<br>
      <strong>Genetic Algorithm O(pop times gen times n)</strong>: Evolutionary optimization with crossover and mutation<br>
      <strong>Brute Force O(n!)</strong>: Exhaustive search for optimal solution (uses Held-Karp O(2^n times n squared) for n greater than 10)<br>
      <br>
      <strong>Efficiency Calculation:</strong> All efficiencies are calculated as (optimal_length / algorithm_length) times 100%,
      where optimal_length is determined by the Brute Force algorithm. Efficiency is capped at 100%.
    </div>
  </div>

  <script>
    // Configuration - using modules from ./algorithms folder
    // Use 13 points for guaranteed true optimal via brute force O(n!)
    // This ensures efficiency calculations are always accurate (no algorithm can exceed 100%)
    const NUM_POINTS = 18;
    const GRID_SIZE = 40;

    // Generate random seed for variety on each reload
    const initialSeed = Math.floor(Math.random() * 1000000);

    // Use utility functions from loaded modules
    const distance = TSPUtils.distance;
    const createDistanceMatrix = TSPUtils.createDistanceMatrix;
    const calculateTourLength = TSPUtils.calculateTourLength;
    const calculateMST = TSPUtils.calculateMST;

    // Generate points on a virtual grid for consistent placement
    const generateNormalizedPoints = (numPoints, gridSize = GRID_SIZE, seed = initialSeed) => {
      let currentSeed = seed;
      const rng = () => {
        currentSeed = (currentSeed * 1103515245 + 12345) % (2**31);
        return currentSeed / (2**31);
      };

      const center = 0.5;
      const maxRadius = 0.45;
      const gridStep = 1 / gridSize;
      const validPositions = [];

      for (let gx = 0; gx < gridSize; gx++) {
        for (let gy = 0; gy < gridSize; gy++) {
          const x = (gx + 0.5) * gridStep;
          const y = (gy + 0.5) * gridStep;
          const dx = x - center;
          const dy = y - center;
          const distFromCenter = Math.sqrt(dx * dx + dy * dy);

          if (distFromCenter <= maxRadius) {
            const angle = Math.atan2(dy, dx);
            validPositions.push({ x, y, angle: angle < 0 ? angle + 2 * Math.PI : angle, gx, gy });
          }
        }
      }

      // Fisher-Yates shuffle
      for (let i = validPositions.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [validPositions[i], validPositions[j]] = [validPositions[j], validPositions[i]];
      }

      const points = validPositions.slice(0, Math.min(numPoints, validPositions.length));
      return points.map((p, idx) => ({ ...p, id: idx }));
    };

    const scalePointsToPercent = (normalizedPoints) => {
      return normalizedPoints.map(p => ({
        ...p,
        percentX: p.x * 100,
        percentY: p.y * 100
      }));
    };

    // Calculate efficiency: optimal/solution * 100 (capped at 100%)
    function calculateEfficiency(solutionLength, optimalLength) {
      if (solutionLength <= 0) return 0;
      const efficiency = (optimalLength / solutionLength) * 100;
      return Math.min(efficiency, 100); // Cap at 100% for display
    }

    // Drawing functions
    function drawLineSegment(container, start, end, color = "green", opacity = 1) {
      const dx = end.percentX - start.percentX;
      const dy = end.percentY - start.percentY;
      const length = Math.hypot(dx, dy);
      const deg = Math.atan2(dy, dx) * 180 / Math.PI;

      const newdiv = document.createElement('div');
      newdiv.className = 'line-segment';
      newdiv.style.width = length + "%";
      newdiv.style.left = start.percentX + "%";
      newdiv.style.top = start.percentY + "%";
      newdiv.style.background = color;
      newdiv.style.opacity = opacity;
      newdiv.style.transform = "rotate(" + deg + "deg)";

      container.appendChild(newdiv);
    }

    function displayPoints(container, points) {
      points.forEach(({ percentX, percentY }) => {
        const pointDiv = document.createElement('div');
        pointDiv.classList.add('point');
        pointDiv.style.left = percentX + "%";
        pointDiv.style.top = percentY + "%";
        container.appendChild(pointDiv);
      });
    }

    function visualizeTour(container, points, tour, color = "green") {
      for (let i = 0; i < tour.length; i++) {
        const start = points[tour[i]];
        const end = points[tour[(i + 1) % tour.length]];
        drawLineSegment(container, start, end, color);
      }
    }

    // Algorithm runner functions using loaded modules
    async function runSonarVisit(container, points, graph, optimalLength) {
      const startTime = performance.now();
      const tour = SonarVisit.generateTour(points, GRID_SIZE);
      const pathLength = calculateTourLength(tour, graph);
      visualizeTour(container, points, tour, "#17a2b8");
      const endTime = performance.now();
      return {
        pathLength,
        efficiency: calculateEfficiency(pathLength, optimalLength),
        runtime: endTime - startTime,
        complexity: "O(1)*",
        bestFor: "Constant-time approximation"
      };
    }

    async function runSonarVisitZigzag(container, points, graph, optimalLength) {
      const startTime = performance.now();
      let tour = SonarVisit.generateTour(points, GRID_SIZE);
      tour = Zigzag.optimize(tour, points, graph);
      const pathLength = calculateTourLength(tour, graph);
      visualizeTour(container, points, tour, "#20c997");
      const endTime = performance.now();
      return {
        pathLength,
        efficiency: calculateEfficiency(pathLength, optimalLength),
        runtime: endTime - startTime,
        complexity: "O(n)",
        bestFor: "Fast local optimization"
      };
    }

    async function runSonarVisit2Opt(container, points, graph, optimalLength) {
      const startTime = performance.now();
      let tour = SonarVisit.generateTour(points, GRID_SIZE);
      tour = TwoOpt.improve(tour, graph);
      const pathLength = calculateTourLength(tour, graph);
      visualizeTour(container, points, tour, "#007bff");
      const endTime = performance.now();
      return {
        pathLength,
        efficiency: calculateEfficiency(pathLength, optimalLength),
        runtime: endTime - startTime,
        complexity: "O(n^2)",
        bestFor: "High-quality from O(1) base"
      };
    }

    async function runSonarVisitZigzag2Opt(container, points, graph, optimalLength) {
      const startTime = performance.now();
      let tour = SonarVisit.generateTour(points, GRID_SIZE);
      tour = Zigzag.optimize(tour, points, graph);
      tour = TwoOpt.improve(tour, graph);
      const pathLength = calculateTourLength(tour, graph);
      visualizeTour(container, points, tour, "#6f42c1");
      const endTime = performance.now();
      return {
        pathLength,
        efficiency: calculateEfficiency(pathLength, optimalLength),
        runtime: endTime - startTime,
        complexity: "O(n^2)",
        bestFor: "Local then global optimization"
      };
    }

    async function runSonarVisit2OptZigzag(container, points, graph, optimalLength) {
      const startTime = performance.now();
      let tour = SonarVisit.generateTour(points, GRID_SIZE);
      tour = TwoOpt.improve(tour, graph);
      tour = Zigzag.optimize(tour, points, graph);
      const pathLength = calculateTourLength(tour, graph);
      visualizeTour(container, points, tour, "#e83e8c");
      const endTime = performance.now();
      return {
        pathLength,
        efficiency: calculateEfficiency(pathLength, optimalLength),
        runtime: endTime - startTime,
        complexity: "O(n^2)",
        bestFor: "Global then local optimization"
      };
    }

    async function runAngularSort(container, points, graph, optimalLength) {
      const startTime = performance.now();
      const tour = AngularSort.generateTour(points);
      const pathLength = calculateTourLength(tour, graph);
      visualizeTour(container, points, tour, "#fd7e14");
      const endTime = performance.now();
      return {
        pathLength,
        efficiency: calculateEfficiency(pathLength, optimalLength),
        runtime: endTime - startTime,
        complexity: "O(n log n)",
        bestFor: "Quick approximate solutions"
      };
    }

    async function runAngularSortZigzag(container, points, graph, optimalLength) {
      const startTime = performance.now();
      let tour = AngularSort.generateTour(points);
      tour = Zigzag.optimize(tour, points, graph);
      const pathLength = calculateTourLength(tour, graph);
      visualizeTour(container, points, tour, "#28a745");
      const endTime = performance.now();
      return {
        pathLength,
        efficiency: calculateEfficiency(pathLength, optimalLength),
        runtime: endTime - startTime,
        complexity: "O(n log n)",
        bestFor: "Local optimization"
      };
    }

    async function runAngularSort2Opt(container, points, graph, optimalLength) {
      const startTime = performance.now();
      let tour = AngularSort.generateTour(points);
      tour = TwoOpt.improve(tour, graph);
      const pathLength = calculateTourLength(tour, graph);
      visualizeTour(container, points, tour, "#dc3545");
      const endTime = performance.now();
      return {
        pathLength,
        efficiency: calculateEfficiency(pathLength, optimalLength),
        runtime: endTime - startTime,
        complexity: "O(n^2)",
        bestFor: "High-quality solutions"
      };
    }

    async function runAngularSortZigzag2Opt(container, points, graph, optimalLength) {
      const startTime = performance.now();
      let tour = AngularSort.generateTour(points);
      tour = Zigzag.optimize(tour, points, graph);
      tour = TwoOpt.improve(tour, graph);
      const pathLength = calculateTourLength(tour, graph);
      visualizeTour(container, points, tour, "#6610f2");
      const endTime = performance.now();
      return {
        pathLength,
        efficiency: calculateEfficiency(pathLength, optimalLength),
        runtime: endTime - startTime,
        complexity: "O(n^2)",
        bestFor: "Local then global optimization"
      };
    }

    async function runAngularSort2OptZigzag(container, points, graph, optimalLength) {
      const startTime = performance.now();
      let tour = AngularSort.generateTour(points);
      tour = TwoOpt.improve(tour, graph);
      tour = Zigzag.optimize(tour, points, graph);
      const pathLength = calculateTourLength(tour, graph);
      visualizeTour(container, points, tour, "#795548");
      const endTime = performance.now();
      return {
        pathLength,
        efficiency: calculateEfficiency(pathLength, optimalLength),
        runtime: endTime - startTime,
        complexity: "O(n^2)",
        bestFor: "Global then local optimization"
      };
    }

    async function runNearestNeighbor(container, points, graph, optimalLength) {
      const startTime = performance.now();
      const tour = NearestNeighbor.generateTour(points, graph);
      const pathLength = calculateTourLength(tour, graph);
      visualizeTour(container, points, tour, "#ff6b6b");
      const endTime = performance.now();
      return {
        pathLength,
        efficiency: calculateEfficiency(pathLength, optimalLength),
        runtime: endTime - startTime,
        complexity: "O(n^2)",
        bestFor: "Fast approximate solution"
      };
    }

    async function runGreedyEdge(container, points, graph, optimalLength) {
      const startTime = performance.now();
      const tour = GreedyEdge.generateTour(points, graph);
      const pathLength = calculateTourLength(tour, graph);
      visualizeTour(container, points, tour, "#4ecdc4");
      const endTime = performance.now();
      return {
        pathLength,
        efficiency: calculateEfficiency(pathLength, optimalLength),
        runtime: endTime - startTime,
        complexity: "O(n^2 log n)",
        bestFor: "Good average performance"
      };
    }

    async function runSimulatedAnnealing(container, points, graph, optimalLength) {
      const startTime = performance.now();
      const initialTour = NearestNeighbor.generateTour(points, graph);
      const tour = SimulatedAnnealing.optimize(graph, initialTour);
      const pathLength = calculateTourLength(tour, graph);
      visualizeTour(container, points, tour, "#9b59b6");
      const endTime = performance.now();
      return {
        pathLength,
        efficiency: calculateEfficiency(pathLength, optimalLength),
        runtime: endTime - startTime,
        complexity: "O(n * iter)",
        bestFor: "Near-optimal solutions"
      };
    }

    async function runGeneticAlgorithm(container, points, graph, optimalLength) {
      const startTime = performance.now();
      const tour = GeneticAlgorithm.optimize(graph, points.length);
      const pathLength = calculateTourLength(tour, graph);
      visualizeTour(container, points, tour, "#e67e22");
      const endTime = performance.now();
      return {
        pathLength,
        efficiency: calculateEfficiency(pathLength, optimalLength),
        runtime: endTime - startTime,
        complexity: "O(pop * gen * n)",
        bestFor: "Large-scale optimization"
      };
    }

    async function runBruteForce(container, points, graph) {
      const startTime = performance.now();
      const result = BruteForce.findOptimal(graph, points.length);
      const tour = result.tour;
      const pathLength = result.length;
      visualizeTour(container, points, tour, "#2c3e50");
      const endTime = performance.now();
      return {
        pathLength,
        efficiency: 100.0, // By definition, brute force is optimal
        runtime: endTime - startTime,
        complexity: points.length <= 10 ? "O(n!)" : "O(2^n * n^2)",
        bestFor: "Optimal reference (small n)"
      };
    }

    // Main execution
    async function runComparison() {
      const results = [];
      const numMethods = 15;

      const containers = [];
      for (let i = 1; i <= numMethods; i++) {
        containers.push(document.getElementById(`canvas${i}`));
      }

      // Generate normalized points once (same for all canvases)
      const normalizedPoints = generateNormalizedPoints(NUM_POINTS);
      const points = scalePointsToPercent(normalizedPoints);
      const graph = createDistanceMatrix(points);

      containers.forEach(container => {
        displayPoints(container, points);
        container.points = points;
        container.graph = graph;
      });

      // First, run brute force to get optimal solution
      document.getElementById('stats15').innerHTML = 'Computing optimal solution...';
      document.getElementById('progress15').style.width = '50%';
      await new Promise(resolve => setTimeout(resolve, 10));

      const bruteForceResult = await runBruteForce(containers[14], points, graph);
      bruteForceResult.name = "Brute Force (Optimal)";

      const optimalLength = bruteForceResult.pathLength;
      console.log(`Optimal tour length: ${optimalLength.toFixed(4)}`);

      document.getElementById('progress15').style.width = '100%';
      document.getElementById('stats15').innerHTML = `
        <div>Path Length: ${bruteForceResult.pathLength.toFixed(2)}</div>
        <div>Efficiency: ${bruteForceResult.efficiency.toFixed(1)}%</div>
        <div>Runtime: ${bruteForceResult.runtime.toFixed(1)}ms</div>
      `;

      // Define all methods
      const methods = [
        { name: "Sonar Visit", fn: runSonarVisit, id: 1 },
        { name: "Sonar Visit + Zigzag", fn: runSonarVisitZigzag, id: 2 },
        { name: "Sonar Visit + 2-Opt", fn: runSonarVisit2Opt, id: 3 },
        { name: "Sonar Visit + Zigzag + 2-Opt", fn: runSonarVisitZigzag2Opt, id: 4 },
        { name: "Sonar Visit + 2-Opt + Zigzag", fn: runSonarVisit2OptZigzag, id: 5 },
        { name: "Angular Sort", fn: runAngularSort, id: 6 },
        { name: "Angular Sort + Zigzag", fn: runAngularSortZigzag, id: 7 },
        { name: "Angular Sort + 2-Opt", fn: runAngularSort2Opt, id: 8 },
        { name: "Angular Sort + Zigzag + 2-Opt", fn: runAngularSortZigzag2Opt, id: 9 },
        { name: "Angular Sort + 2-Opt + Zigzag", fn: runAngularSort2OptZigzag, id: 10 },
        { name: "Nearest Neighbor", fn: runNearestNeighbor, id: 11 },
        { name: "Greedy (Nearest Edge)", fn: runGreedyEdge, id: 12 },
        { name: "Simulated Annealing", fn: runSimulatedAnnealing, id: 13 },
        { name: "Genetic Algorithm", fn: runGeneticAlgorithm, id: 14 }
      ];

      // Execute methods sequentially
      for (let i = 0; i < methods.length; i++) {
        const method = methods[i];
        const container = containers[method.id - 1];

        document.getElementById(`progress${method.id}`).style.width = '50%';
        await new Promise(resolve => setTimeout(resolve, 50));

        const result = await method.fn(container, container.points, container.graph, optimalLength);
        result.name = method.name;
        results.push(result);

        document.getElementById(`progress${method.id}`).style.width = '100%';
        document.getElementById(`stats${method.id}`).innerHTML = `
          <div>Path Length: ${result.pathLength.toFixed(2)}</div>
          <div>Efficiency: ${result.efficiency.toFixed(1)}%</div>
          <div>Runtime: ${result.runtime.toFixed(1)}ms</div>
        `;
      }

      // Add brute force result at the end
      results.push(bruteForceResult);

      // Update comparison table
      const tbody = document.getElementById('results-tbody');
      tbody.innerHTML = '';

      const bestPath = Math.min(...results.map(r => r.pathLength));
      const bestEfficiency = Math.max(...results.map(r => r.efficiency));
      const bestRuntime = Math.min(...results.map(r => r.runtime));

      results.forEach(result => {
        const row = tbody.insertRow();
        row.innerHTML = `
          <td>${result.name}</td>
          <td class="${result.pathLength === bestPath ? 'best' : ''}">${result.pathLength.toFixed(2)}</td>
          <td class="${result.efficiency === bestEfficiency ? 'best' : ''}">${result.efficiency.toFixed(1)}%</td>
          <td class="${result.runtime === bestRuntime ? 'best' : ''}">${result.runtime.toFixed(1)}ms</td>
          <td>${result.complexity}</td>
          <td>${result.bestFor}</td>
        `;
      });
    }

    // Debounce function for resize handler
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // Re-render canvases on resize
    const handleResize = debounce(() => {
      const numMethods = 15;
      for (let i = 1; i <= numMethods; i++) {
        const container = document.getElementById(`canvas${i}`);
        container.innerHTML = '';
        document.getElementById(`progress${i}`).style.width = '0%';
        document.getElementById(`stats${i}`).innerHTML = 'Resizing...';
      }
      runComparison();
    }, 250);

    window.addEventListener('resize', handleResize);

    // Set grid info text
    document.getElementById('grid-info').textContent =
      `${NUM_POINTS} points placed on a virtual ${GRID_SIZE}x${GRID_SIZE} grid. True optimal found via brute force.`;

    // Start comparison
    runComparison();
  </script>
</body>

</html>
