<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sonar Visit Algorithm - 360 Degree Rotation Sweep</title>
  <script src="algorithms/utils.js"></script>
  <script src="algorithms/sonar-visit.js"></script>
  <style>
    :root {
      font-size: 16px;
    }

    body {
      margin: 0;
      padding: 1.25rem;
      background: #f0f0f0;
      font-family: Arial, sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .header {
      text-align: center;
      margin-bottom: 1.875rem;
    }

    .header h1 {
      color: #333;
      margin-bottom: 0.5rem;
    }

    .header p {
      color: #666;
      margin: 0.25rem 0;
    }

    .header-info {
      font-size: 0.75rem;
      color: #666;
      margin-top: 0.625rem;
    }

    .header-info a {
      color: #007bff;
      text-decoration: none;
    }

    .header-info a:hover {
      text-decoration: underline;
    }

    .main-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.25rem;
      width: 100%;
      max-width: 50rem;
    }

    .canvas-container {
      position: relative;
      width: 100%;
      max-width: 31.25rem;
      padding-bottom: min(100%, 31.25rem);
      background: white;
      border: 0.0625rem solid #ccc;
      border-radius: 50%;
      box-sizing: border-box;
    }

    .canvas-inner {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .rotating-line {
      position: absolute;
      width: 0.125rem;
      height: 50%;
      background: blue;
      transform-origin: bottom center;
      left: 50%;
      bottom: 50%;
      transform: translateX(-50%) rotate(0deg);
      z-index: 10;
    }

    .point {
      position: absolute;
      width: 0.5rem;
      height: 0.5rem;
      background: red;
      border-radius: 50%;
      transform: translate(-50%, -50%);
    }

    .line-segment {
      position: absolute;
      height: 0.125rem;
      transform-origin: left center;
      pointer-events: none;
    }

    .stats-container {
      background: white;
      border-radius: 0.625rem;
      padding: 1.25rem;
      box-shadow: 0 0.125rem 0.625rem rgba(0, 0, 0, 0.1);
      width: 100%;
      max-width: 31.25rem;
    }

    .stats {
      font-size: 0.875rem;
      color: #333;
    }

    .stats div {
      margin: 0.5rem 0;
    }

    .algorithm-description {
      background: white;
      border-radius: 0.625rem;
      padding: 1.25rem;
      box-shadow: 0 0.125rem 0.625rem rgba(0, 0, 0, 0.1);
      width: 100%;
      max-width: 31.25rem;
    }

    .algorithm-description h2 {
      font-size: 1.125rem;
      margin-top: 0;
      margin-bottom: 1rem;
      color: #333;
    }

    .algorithm-description p {
      font-size: 0.875rem;
      color: #666;
      line-height: 1.6;
      margin: 0.5rem 0;
    }

    .algorithm-description ul {
      font-size: 0.875rem;
      color: #666;
      line-height: 1.6;
      padding-left: 1.25rem;
    }

    .complexity-badge {
      display: inline-block;
      background: #17a2b8;
      color: white;
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.75rem;
      font-weight: bold;
    }

    @media (max-width: 48rem) {
      body {
        padding: 0.75rem;
      }

      .header h1 {
        font-size: 1.5rem;
      }

      .canvas-container {
        max-width: 100%;
        padding-bottom: 100%;
      }

      .stats-container,
      .algorithm-description {
        padding: 1rem;
      }
    }

    @media (max-width: 30rem) {
      :root {
        font-size: 14px;
      }
    }
  </style>
</head>

<body>
  <div class="header">
    <h1>Sonar Visit Algorithm</h1>
    <p>360 Degree Rotation Sweep for Path Optimization</p>
    <p id="grid-info" class="header-info"></p>
    <p class="header-info">
      <a href="https://github.com/konard/sonar" target="_blank" rel="noopener noreferrer">View source code on GitHub</a>
    </p>
  </div>

  <div class="main-content">
    <div class="canvas-container">
      <div class="canvas-inner" id="canvas">
        <div class="rotating-line" id="rotating-line"></div>
      </div>
    </div>

    <div class="stats-container">
      <div class="stats" id="stats">Initializing...</div>
    </div>

    <div class="algorithm-description">
      <h2>How Sonar Visit Works <span class="complexity-badge">O(1)*</span></h2>
      <p>
        The Sonar Visit algorithm is inspired by sonar radar sweep. It performs a 360-degree rotation sweep
        in fixed angle steps, connecting points as they are encountered by the rotating line.
      </p>
      <p><strong>Key characteristics:</strong></p>
      <ul>
        <li>Uses fixed angle steps determined by grid resolution, not point count</li>
        <li>Points on the same angle are connected by distance from center (closest first)</li>
        <li>The number of angle steps is O(1) with respect to point count</li>
        <li>Each point has its angle pre-calculated when placed on the grid</li>
      </ul>
      <p>
        <strong>*Complexity note:</strong> The sweep uses a fixed number of angle steps (4 times GRID_SIZE),
        making the core algorithm constant-time. Point assignment to angle buckets is O(n).
      </p>
    </div>
  </div>

  <script>
    // Configuration
    const NUM_POINTS = 32;
    const GRID_SIZE = 40;
    const ANIMATION_SPEED = 0.5; // degrees per frame

    // Use utility functions from loaded modules
    const distance = TSPUtils.distance;
    const createDistanceMatrix = TSPUtils.createDistanceMatrix;
    const calculateTourLength = TSPUtils.calculateTourLength;

    // Generate random seed for variety on each reload
    const initialSeed = Math.floor(Math.random() * 1000000);

    // Generate points on a virtual grid for consistent placement
    const generateNormalizedPoints = (numPoints, gridSize = GRID_SIZE, seed = initialSeed) => {
      let currentSeed = seed;
      const rng = () => {
        currentSeed = (currentSeed * 1103515245 + 12345) % (2 ** 31);
        return currentSeed / (2 ** 31);
      };

      const center = 0.5;
      const maxRadius = 0.45;
      const gridStep = 1 / gridSize;
      const validPositions = [];

      for (let gx = 0; gx < gridSize; gx++) {
        for (let gy = 0; gy < gridSize; gy++) {
          const x = (gx + 0.5) * gridStep;
          const y = (gy + 0.5) * gridStep;
          const dx = x - center;
          const dy = y - center;
          const distFromCenter = Math.sqrt(dx * dx + dy * dy);

          if (distFromCenter <= maxRadius) {
            // Pre-calculate angle at grid placement time
            const angle = Math.atan2(dy, dx);
            validPositions.push({
              x,
              y,
              angle: angle < 0 ? angle + 2 * Math.PI : angle,
              gx,
              gy
            });
          }
        }
      }

      // Fisher-Yates shuffle
      for (let i = validPositions.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [validPositions[i], validPositions[j]] = [validPositions[j], validPositions[i]];
      }

      const points = validPositions.slice(0, Math.min(numPoints, validPositions.length));
      return points.map((p, idx) => ({ ...p, id: idx }));
    };

    const scalePointsToPercent = (normalizedPoints) => {
      return normalizedPoints.map(p => ({
        ...p,
        percentX: p.x * 100,
        percentY: p.y * 100
      }));
    };

    // Drawing functions using percentage-based positioning
    function drawLineSegment(container, start, end, color = "green", opacity = 1) {
      const dx = end.percentX - start.percentX;
      const dy = end.percentY - start.percentY;
      const length = Math.hypot(dx, dy);
      const deg = Math.atan2(dy, dx) * 180 / Math.PI;

      const newdiv = document.createElement('div');
      newdiv.className = 'line-segment';
      newdiv.style.width = length + "%";
      newdiv.style.left = start.percentX + "%";
      newdiv.style.top = start.percentY + "%";
      newdiv.style.background = color;
      newdiv.style.opacity = opacity;
      newdiv.style.transform = "rotate(" + deg + "deg)";

      container.appendChild(newdiv);
    }

    function displayPoints(container, points) {
      points.forEach(({ percentX, percentY }) => {
        const pointDiv = document.createElement('div');
        pointDiv.classList.add('point');
        pointDiv.style.left = percentX + "%";
        pointDiv.style.top = percentY + "%";
        container.appendChild(pointDiv);
      });
    }

    function visualizeTour(container, points, tour, color = "#17a2b8") {
      for (let i = 0; i < tour.length; i++) {
        const start = points[tour[i]];
        const end = points[tour[(i + 1) % tour.length]];
        drawLineSegment(container, start, end, color);
      }
    }

    // Main execution with animated sweep
    async function runSonarVisualization() {
      const container = document.getElementById('canvas');
      const line = document.getElementById('rotating-line');
      const statsDiv = document.getElementById('stats');

      // Generate normalized points (each with pre-calculated angle)
      const normalizedPoints = generateNormalizedPoints(NUM_POINTS);
      const points = scalePointsToPercent(normalizedPoints);
      const graph = createDistanceMatrix(points);

      // Display points
      displayPoints(container, points);

      // Update grid info
      document.getElementById('grid-info').textContent =
        `${NUM_POINTS} points on a ${GRID_SIZE}x${GRID_SIZE} virtual grid`;

      // Animate the rotating line sweep
      let currentAngle = 0;
      const angleSteps = 4 * GRID_SIZE;
      const angleStep = 360 / angleSteps;

      // Track connected points for visualization
      const connectedPoints = [];
      const pointsByAngle = new Map();

      // Group points by their angle bucket
      points.forEach((point, idx) => {
        const bucketIndex = Math.floor((point.angle / (2 * Math.PI)) * angleSteps);
        if (!pointsByAngle.has(bucketIndex)) {
          pointsByAngle.set(bucketIndex, []);
        }
        pointsByAngle.get(bucketIndex).push({ ...point, id: idx });
      });

      // Sort points within each bucket by distance from center
      const center = { percentX: 50, percentY: 50 };
      pointsByAngle.forEach((bucketPoints) => {
        bucketPoints.sort((a, b) => {
          const distA = Math.hypot(a.percentX - center.percentX, a.percentY - center.percentY);
          const distB = Math.hypot(b.percentX - center.percentX, b.percentY - center.percentY);
          return distA - distB;
        });
      });

      // Animation function
      let currentBucket = 0;
      function animate() {
        // Rotate line
        line.style.transform = `translateX(-50%) rotate(${currentAngle + 90}deg)`;

        // Check for points at current angle bucket
        if (pointsByAngle.has(currentBucket)) {
          const bucketPoints = pointsByAngle.get(currentBucket);
          bucketPoints.forEach(point => {
            if (!connectedPoints.includes(point.id)) {
              if (connectedPoints.length > 0) {
                const lastPointId = connectedPoints[connectedPoints.length - 1];
                drawLineSegment(container, points[lastPointId], points[point.id], "#17a2b8", 0.8);
              }
              connectedPoints.push(point.id);
            }
          });
        }

        currentAngle += ANIMATION_SPEED;
        currentBucket = Math.floor((currentAngle / 360) * angleSteps) % angleSteps;

        // Continue until we complete two full rotations
        if (currentAngle < 720) {
          requestAnimationFrame(animate);
        } else {
          // Connect last point to first to complete the tour
          if (connectedPoints.length > 1) {
            const lastPointId = connectedPoints[connectedPoints.length - 1];
            const firstPointId = connectedPoints[0];
            drawLineSegment(container, points[lastPointId], points[firstPointId], "#17a2b8", 0.8);
          }

          // Calculate and display final statistics
          const tour = SonarVisit.generateTour(normalizedPoints, GRID_SIZE);
          const pathLength = calculateTourLength(tour, graph);

          statsDiv.innerHTML = `
            <div><strong>Algorithm:</strong> Sonar Visit (360-degree sweep)</div>
            <div><strong>Points:</strong> ${NUM_POINTS}</div>
            <div><strong>Path Length:</strong> ${pathLength.toFixed(2)}</div>
            <div><strong>Tour Order:</strong> ${tour.slice(0, 10).join(' -> ')}${tour.length > 10 ? ' ...' : ''}</div>
            <div><strong>Complexity:</strong> O(1) angle steps + O(n) point assignment</div>
          `;

          // Hide the rotating line
          line.style.display = 'none';
        }
      }

      // Start animation
      statsDiv.innerHTML = '<div>Sweeping...</div>';
      animate();
    }

    // Start visualization when page loads
    runSonarVisualization();
  </script>
</body>

</html>
