<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="initial-scale=1.0">
  <title>2-Opt Path Optimization - Side by Side</title>
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      padding: 20px;
      background: #f0f0f0;
      font-family: Arial, sans-serif;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
    }

    .comparison-container {
      display: flex;
      gap: 40px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .panel {
      background: white;
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    .panel-title {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 10px;
      text-align: center;
      color: #333;
    }

    .canvas-container {
      position: relative;
      width: 400px;
      height: 400px;
      background: white;
      border: 1px solid #ccc;
      border-radius: 50%;
    }

    .point {
      position: absolute;
      width: 8px;
      height: 8px;
      background: red;
      border-radius: 50%;
    }

    .stats {
      font-size: 12px;
      background: #f8f9fa;
      padding: 10px;
      border-radius: 5px;
      margin-top: 15px;
    }

    .improvement {
      margin-top: 20px;
      padding: 15px;
      background: #d4edda;
      border-radius: 10px;
      text-align: center;
      font-weight: bold;
    }

    .legend {
      display: flex;
      gap: 20px;
      justify-content: center;
      margin-top: 10px;
      font-size: 12px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .legend-color {
      width: 20px;
      height: 3px;
    }
  </style>
</head>

<body>
  <div class="header">
    <h1>2-Opt Path Optimization</h1>
    <p>Side-by-side comparison: Without optimization vs With 2-opt optimization</p>
  </div>

  <div class="comparison-container">
    <div class="panel">
      <div class="panel-title">Without Optimization (Nearest Neighbor)</div>
      <div class="canvas-container" id="canvas-unoptimized"></div>
      <div class="legend">
        <div class="legend-item">
          <div class="legend-color" style="background: blue;"></div>
          <span>Initial tour (nearest neighbor)</span>
        </div>
      </div>
      <div class="stats" id="stats-unoptimized">Initializing...</div>
    </div>

    <div class="panel">
      <div class="panel-title">With 2-Opt Optimization</div>
      <div class="canvas-container" id="canvas-optimized"></div>
      <div class="legend">
        <div class="legend-item">
          <div class="legend-color" style="background: green;"></div>
          <span>Optimized tour (2-opt)</span>
        </div>
      </div>
      <div class="stats" id="stats-optimized">Initializing...</div>
    </div>
  </div>

  <div class="improvement" id="improvement">Calculating improvement...</div>

  <script>
    function randomIntFromInterval(min, max) {
      return Math.floor(Math.random() * (max - min + 1) + min);
    }

    const NUM_POINTS = randomIntFromInterval(30, 80);

    // Generate random points with a random seed (different on each reload)
    const generateRandomPoints = (numPoints, radius, centerX, centerY) => {
      const points = [];
      for (let i = 0; i < numPoints; i++) {
        const angle = Math.random() * 2 * Math.PI;
        const r = Math.sqrt(Math.random()) * radius;
        const x = r * Math.cos(angle) + centerX;
        const y = r * Math.sin(angle) + centerY;
        points.push({ x, y, angle, id: i });
      }
      return points;
    };

    const distance = (start, end) => Math.hypot(end.y - start.y, end.x - start.x);

    function createDistanceMatrix(points) {
      const n = points.length;
      const graph = Array.from({ length: n }, () => Array(n).fill(0));
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          if (i !== j) {
            graph[i][j] = distance(points[i], points[j]);
          }
        }
      }
      return graph;
    }

    function calculateMST(graph) {
      const n = graph.length;
      const selected = new Array(n).fill(false);
      selected[0] = true;
      let edgeCount = 0;
      let mstWeight = 0;

      while (edgeCount < n - 1) {
        let min = Infinity;
        let x = 0, y = 0;
        for (let i = 0; i < n; i++) {
          if (selected[i]) {
            for (let j = 0; j < n; j++) {
              if (!selected[j] && graph[i][j]) {
                if (min > graph[i][j]) {
                  min = graph[i][j];
                  x = i;
                  y = j;
                }
              }
            }
          }
        }
        mstWeight += graph[x][y];
        selected[y] = true;
        edgeCount++;
      }
      return mstWeight;
    }

    function calculateUpperBound(graph) {
      const n = graph.length;
      let maxTour = 0;
      for (let i = 0; i < n; i++) {
        let maxEdge = Math.max(...graph[i]);
        maxTour += maxEdge;
      }
      return maxTour;
    }

    function nearestNeighborTour(points, graph) {
      const n = points.length;
      const visited = new Array(n).fill(false);
      const tour = [0];
      visited[0] = true;
      let current = 0;

      for (let step = 1; step < n; step++) {
        let nearest = -1;
        let minDist = Infinity;

        for (let j = 0; j < n; j++) {
          if (!visited[j] && graph[current][j] < minDist) {
            minDist = graph[current][j];
            nearest = j;
          }
        }

        tour.push(nearest);
        visited[nearest] = true;
        current = nearest;
      }

      return tour;
    }

    function calculateTourLength(tour, graph) {
      let totalDistance = 0;
      const n = tour.length;
      for (let i = 0; i < n; i++) {
        totalDistance += graph[tour[i]][tour[(i + 1) % n]];
      }
      return totalDistance;
    }

    function twoOptImprove(tour, graph, maxIterations = 1000) {
      const n = tour.length;
      let improved = true;
      let iterations = 0;
      let improvements = 0;

      while (improved && iterations < maxIterations) {
        improved = false;
        iterations++;

        for (let i = 0; i < n - 1; i++) {
          for (let j = i + 2; j < n; j++) {
            if (j === n - 1 && i === 0) continue;

            const currentDistance = graph[tour[i]][tour[i + 1]] + graph[tour[j]][tour[(j + 1) % n]];
            const newDistance = graph[tour[i]][tour[j]] + graph[tour[i + 1]][tour[(j + 1) % n]];

            if (newDistance < currentDistance) {
              const newTour = [...tour];
              for (let k = 0; k <= j - i - 1; k++) {
                newTour[i + 1 + k] = tour[j - k];
              }
              tour = newTour;
              improved = true;
              improvements++;
            }
          }
        }
      }

      return { tour, improvements, iterations };
    }

    function calculateEfficiency(solutionPathLength, minimumPossiblePathLength, maximumPossiblePathLength) {
      return ((maximumPossiblePathLength - solutionPathLength) / (maximumPossiblePathLength - minimumPossiblePathLength)) * 100;
    }

    function displayPoints(container, points) {
      points.forEach(({ x, y }) => {
        const pointDiv = document.createElement('div');
        pointDiv.classList.add('point');
        pointDiv.style.left = `${x - 4}px`;
        pointDiv.style.top = `${y - 4}px`;
        container.appendChild(pointDiv);
      });
    }

    function drawLineSegment(container, start, end, color = "green", opacity = 1) {
      const length = Math.hypot(end.y - start.y, end.x - start.x);
      const deg = Math.atan2(end.y - start.y, end.x - start.x) * 180 / Math.PI;

      const newdiv = document.createElement('div');
      newdiv.style.width = length + "px";
      newdiv.style.height = "2px";
      newdiv.style.left = start.x + "px";
      newdiv.style.top = start.y + "px";
      newdiv.style.background = color;
      newdiv.style.opacity = opacity;
      newdiv.style.transformOrigin = "left 50%";
      newdiv.style.transform = "rotate(" + deg + "deg)";
      newdiv.style.position = "absolute";
      newdiv.style.pointerEvents = "none";

      container.appendChild(newdiv);
    }

    function visualizeTour(container, points, tour, color = "green") {
      for (let i = 0; i < tour.length; i++) {
        const start = points[tour[i]];
        const end = points[tour[(i + 1) % tour.length]];
        drawLineSegment(container, start, end, color);
      }
    }

    async function runComparison() {
      const containerUnoptimized = document.getElementById('canvas-unoptimized');
      const containerOptimized = document.getElementById('canvas-optimized');

      // Generate same points for both panels
      const points = generateRandomPoints(NUM_POINTS, 180, 200, 200);
      const graph = createDistanceMatrix(points);
      const lowerBound = calculateMST(graph);
      const upperBound = calculateUpperBound(graph);

      // Display points on both canvases
      displayPoints(containerUnoptimized, points);
      displayPoints(containerOptimized, points);

      // Get initial tour using nearest neighbor (same for both)
      const initialTour = nearestNeighborTour(points, graph);
      const initialLength = calculateTourLength(initialTour, graph);

      // Visualize unoptimized tour
      visualizeTour(containerUnoptimized, points, initialTour, "blue");
      const initialEfficiency = calculateEfficiency(initialLength, lowerBound, upperBound);

      document.getElementById('stats-unoptimized').innerHTML = `
        <div>Points: ${NUM_POINTS}</div>
        <div>Path Length: ${initialLength.toFixed(2)}</div>
        <div>Bounds: [${lowerBound.toFixed(2)}, ${upperBound.toFixed(2)}]</div>
        <div>Efficiency: ${initialEfficiency.toFixed(2)}%</div>
      `;

      // Apply 2-opt optimization
      await new Promise(resolve => setTimeout(resolve, 300)); // Brief pause

      const result = twoOptImprove([...initialTour], graph);
      const optimizedTour = result.tour;
      const optimizedLength = calculateTourLength(optimizedTour, graph);

      // Visualize optimized tour
      visualizeTour(containerOptimized, points, optimizedTour, "green");
      const optimizedEfficiency = calculateEfficiency(optimizedLength, lowerBound, upperBound);

      document.getElementById('stats-optimized').innerHTML = `
        <div>Points: ${NUM_POINTS}</div>
        <div>Path Length: ${optimizedLength.toFixed(2)}</div>
        <div>Bounds: [${lowerBound.toFixed(2)}, ${upperBound.toFixed(2)}]</div>
        <div>Efficiency: ${optimizedEfficiency.toFixed(2)}%</div>
        <div>Iterations: ${result.iterations}, Improvements: ${result.improvements}</div>
      `;

      // Calculate and display improvement
      const improvement = ((initialLength - optimizedLength) / initialLength * 100);
      const efficiencyGain = optimizedEfficiency - initialEfficiency;

      document.getElementById('improvement').innerHTML = `
        <div>Path Length Reduction: ${improvement.toFixed(2)}%</div>
        <div>Efficiency Improvement: +${efficiencyGain.toFixed(2)} percentage points</div>
        <div>(${initialLength.toFixed(2)} â†’ ${optimizedLength.toFixed(2)})</div>
      `;
    }

    // Start the comparison
    runComparison();
  </script>
</body>

</html>
