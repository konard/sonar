<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2-Opt Path Optimization - Side by Side Comparison</title>
  <script src="algorithms/utils.js"></script>
  <script src="algorithms/nearest-neighbor.js"></script>
  <script src="algorithms/two-opt.js"></script>
  <style>
    :root {
      font-size: 16px;
    }

    body {
      margin: 0;
      padding: 1.25rem;
      background: #f0f0f0;
      font-family: Arial, sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .header {
      text-align: center;
      margin-bottom: 1.875rem;
    }

    .header h1 {
      color: #333;
      margin-bottom: 0.5rem;
    }

    .header p {
      color: #666;
      margin: 0.25rem 0;
    }

    .header-info {
      font-size: 0.75rem;
      color: #666;
      margin-top: 0.625rem;
    }

    .header-info a {
      color: #007bff;
      text-decoration: none;
    }

    .header-info a:hover {
      text-decoration: underline;
    }

    .comparison-container {
      display: flex;
      gap: 2.5rem;
      flex-wrap: wrap;
      justify-content: center;
      margin-bottom: 1.25rem;
    }

    .panel {
      background: white;
      border-radius: 0.625rem;
      padding: 1.25rem;
      box-shadow: 0 0.125rem 0.625rem rgba(0, 0, 0, 0.1);
    }

    .panel-title {
      font-size: 1rem;
      font-weight: bold;
      margin-bottom: 0.625rem;
      text-align: center;
      color: #333;
    }

    .canvas-container {
      position: relative;
      width: 100%;
      max-width: 18.75rem;
      padding-bottom: min(100%, 18.75rem);
      background: white;
      border: 0.0625rem solid #ccc;
      border-radius: 50%;
      box-sizing: border-box;
    }

    .canvas-inner {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .point {
      position: absolute;
      width: 0.4rem;
      height: 0.4rem;
      background: red;
      border-radius: 50%;
      transform: translate(-50%, -50%);
    }

    .line-segment {
      position: absolute;
      height: 0.125rem;
      transform-origin: left center;
      pointer-events: none;
    }

    .stats {
      font-size: 0.75rem;
      background: #f8f9fa;
      padding: 0.625rem;
      border-radius: 0.3125rem;
      margin-top: 0.9375rem;
    }

    .stats div {
      margin: 0.25rem 0;
    }

    .improvement {
      margin-top: 1.25rem;
      padding: 1rem;
      background: #d4edda;
      border-radius: 0.625rem;
      text-align: center;
      font-weight: bold;
      max-width: 37.5rem;
      width: 100%;
    }

    .improvement div {
      margin: 0.25rem 0;
    }

    .legend {
      display: flex;
      gap: 1.25rem;
      justify-content: center;
      margin-top: 0.625rem;
      font-size: 0.75rem;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.3125rem;
    }

    .legend-color {
      width: 1.25rem;
      height: 0.1875rem;
    }

    .algorithm-description {
      background: white;
      border-radius: 0.625rem;
      padding: 1.25rem;
      box-shadow: 0 0.125rem 0.625rem rgba(0, 0, 0, 0.1);
      width: 100%;
      max-width: 50rem;
      margin-top: 1.25rem;
    }

    .algorithm-description h2 {
      font-size: 1.125rem;
      margin-top: 0;
      margin-bottom: 1rem;
      color: #333;
    }

    .algorithm-description p {
      font-size: 0.875rem;
      color: #666;
      line-height: 1.6;
      margin: 0.5rem 0;
    }

    .algorithm-description ul {
      font-size: 0.875rem;
      color: #666;
      line-height: 1.6;
      padding-left: 1.25rem;
    }

    .complexity-badge {
      display: inline-block;
      background: #007bff;
      color: white;
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.75rem;
      font-weight: bold;
    }

    @media (max-width: 48rem) {
      body {
        padding: 0.75rem;
      }

      .comparison-container {
        gap: 1.25rem;
      }

      .panel {
        padding: 1rem;
      }

      .canvas-container {
        max-width: 100%;
        padding-bottom: 100%;
      }

      .algorithm-description {
        padding: 1rem;
      }
    }

    @media (max-width: 30rem) {
      :root {
        font-size: 14px;
      }

      .header h1 {
        font-size: 1.5rem;
      }
    }
  </style>
</head>

<body>
  <div class="header">
    <h1>2-Opt Path Optimization</h1>
    <p>Side-by-side comparison: Without optimization vs With 2-opt optimization</p>
    <p id="grid-info" class="header-info"></p>
    <p class="header-info">
      <a href="https://github.com/konard/sonar" target="_blank" rel="noopener noreferrer">View source code on GitHub</a>
    </p>
  </div>

  <div class="comparison-container">
    <div class="panel">
      <div class="panel-title">Without Optimization (Nearest Neighbor)</div>
      <div class="canvas-container">
        <div class="canvas-inner" id="canvas-unoptimized"></div>
      </div>
      <div class="legend">
        <div class="legend-item">
          <div class="legend-color" style="background: blue;"></div>
          <span>Initial tour (nearest neighbor)</span>
        </div>
      </div>
      <div class="stats" id="stats-unoptimized">Initializing...</div>
    </div>

    <div class="panel">
      <div class="panel-title">With 2-Opt Optimization</div>
      <div class="canvas-container">
        <div class="canvas-inner" id="canvas-optimized"></div>
      </div>
      <div class="legend">
        <div class="legend-item">
          <div class="legend-color" style="background: green;"></div>
          <span>Optimized tour (2-opt)</span>
        </div>
      </div>
      <div class="stats" id="stats-optimized">Initializing...</div>
    </div>
  </div>

  <div class="improvement" id="improvement">Calculating improvement...</div>

  <div class="algorithm-description">
    <h2>How 2-Opt Works <span class="complexity-badge">O(n^2)</span></h2>
    <p>
      The 2-Opt algorithm is a local search optimization that improves a tour by repeatedly
      swapping pairs of edges to reduce the total path length.
    </p>
    <p><strong>Algorithm steps:</strong></p>
    <ul>
      <li>Start with an initial tour (here, from Nearest Neighbor)</li>
      <li>For each pair of non-adjacent edges, check if swapping them reduces the tour length</li>
      <li>If improvement is found, reverse the segment between the swapped edges</li>
      <li>Repeat until no more improvements can be made</li>
    </ul>
    <p><strong>Key insight:</strong></p>
    <p>
      2-Opt eliminates edge crossings. If two edges cross, swapping them will always produce a shorter tour.
      This makes 2-Opt particularly effective at improving tours with many crossings.
    </p>
  </div>

  <script>
    // Configuration
    const NUM_POINTS = 40;
    const GRID_SIZE = 40;

    // Use utility functions from loaded modules
    const distance = TSPUtils.distance;
    const createDistanceMatrix = TSPUtils.createDistanceMatrix;
    const calculateTourLength = TSPUtils.calculateTourLength;
    const calculateMST = TSPUtils.calculateMST;

    // Generate random seed for variety on each reload
    const initialSeed = Math.floor(Math.random() * 1000000);

    // Generate points on a virtual grid for consistent placement
    const generateNormalizedPoints = (numPoints, gridSize = GRID_SIZE, seed = initialSeed) => {
      let currentSeed = seed;
      const rng = () => {
        currentSeed = (currentSeed * 1103515245 + 12345) % (2 ** 31);
        return currentSeed / (2 ** 31);
      };

      const center = 0.5;
      const maxRadius = 0.45;
      const gridStep = 1 / gridSize;
      const validPositions = [];

      for (let gx = 0; gx < gridSize; gx++) {
        for (let gy = 0; gy < gridSize; gy++) {
          const x = (gx + 0.5) * gridStep;
          const y = (gy + 0.5) * gridStep;
          const dx = x - center;
          const dy = y - center;
          const distFromCenter = Math.sqrt(dx * dx + dy * dy);

          if (distFromCenter <= maxRadius) {
            // Pre-calculate angle at grid placement time
            const angle = Math.atan2(dy, dx);
            validPositions.push({
              x,
              y,
              angle: angle < 0 ? angle + 2 * Math.PI : angle,
              gx,
              gy
            });
          }
        }
      }

      // Fisher-Yates shuffle
      for (let i = validPositions.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [validPositions[i], validPositions[j]] = [validPositions[j], validPositions[i]];
      }

      const points = validPositions.slice(0, Math.min(numPoints, validPositions.length));
      return points.map((p, idx) => ({ ...p, id: idx }));
    };

    const scalePointsToPercent = (normalizedPoints) => {
      return normalizedPoints.map(p => ({
        ...p,
        percentX: p.x * 100,
        percentY: p.y * 100
      }));
    };

    // Calculate upper bound for efficiency calculation
    function calculateUpperBound(graph) {
      const n = graph.length;
      let maxTour = 0;
      for (let i = 0; i < n; i++) {
        let maxEdge = Math.max(...graph[i]);
        maxTour += maxEdge;
      }
      return maxTour;
    }

    function calculateEfficiency(solutionPathLength, minimumPossiblePathLength, maximumPossiblePathLength) {
      return ((maximumPossiblePathLength - solutionPathLength) / (maximumPossiblePathLength - minimumPossiblePathLength)) * 100;
    }

    // Drawing functions using percentage-based positioning
    function drawLineSegment(container, start, end, color = "green", opacity = 1) {
      const dx = end.percentX - start.percentX;
      const dy = end.percentY - start.percentY;
      const length = Math.hypot(dx, dy);
      const deg = Math.atan2(dy, dx) * 180 / Math.PI;

      const newdiv = document.createElement('div');
      newdiv.className = 'line-segment';
      newdiv.style.width = length + "%";
      newdiv.style.left = start.percentX + "%";
      newdiv.style.top = start.percentY + "%";
      newdiv.style.background = color;
      newdiv.style.opacity = opacity;
      newdiv.style.transform = "rotate(" + deg + "deg)";

      container.appendChild(newdiv);
    }

    function displayPoints(container, points) {
      points.forEach(({ percentX, percentY }) => {
        const pointDiv = document.createElement('div');
        pointDiv.classList.add('point');
        pointDiv.style.left = percentX + "%";
        pointDiv.style.top = percentY + "%";
        container.appendChild(pointDiv);
      });
    }

    function visualizeTour(container, points, tour, color = "green") {
      for (let i = 0; i < tour.length; i++) {
        const start = points[tour[i]];
        const end = points[tour[(i + 1) % tour.length]];
        drawLineSegment(container, start, end, color);
      }
    }

    async function runComparison() {
      const containerUnoptimized = document.getElementById('canvas-unoptimized');
      const containerOptimized = document.getElementById('canvas-optimized');

      // Generate normalized points (each with pre-calculated angle)
      const normalizedPoints = generateNormalizedPoints(NUM_POINTS);
      const points = scalePointsToPercent(normalizedPoints);
      const graph = createDistanceMatrix(points);
      const lowerBound = calculateMST(graph);
      const upperBound = calculateUpperBound(graph);

      // Display points on both canvases
      displayPoints(containerUnoptimized, points);
      displayPoints(containerOptimized, points);

      // Update grid info
      document.getElementById('grid-info').textContent =
        `${NUM_POINTS} points on a ${GRID_SIZE}x${GRID_SIZE} virtual grid`;

      // Get initial tour using nearest neighbor (same for both)
      const initialTour = NearestNeighbor.generateTour(normalizedPoints, graph);
      const initialLength = calculateTourLength(initialTour, graph);

      // Visualize unoptimized tour
      visualizeTour(containerUnoptimized, points, initialTour, "blue");
      const initialEfficiency = calculateEfficiency(initialLength, lowerBound, upperBound);

      document.getElementById('stats-unoptimized').innerHTML = `
        <div><strong>Points:</strong> ${NUM_POINTS}</div>
        <div><strong>Path Length:</strong> ${initialLength.toFixed(2)}</div>
        <div><strong>Bounds:</strong> [${lowerBound.toFixed(2)}, ${upperBound.toFixed(2)}]</div>
        <div><strong>Efficiency:</strong> ${initialEfficiency.toFixed(2)}%</div>
      `;

      // Apply 2-opt optimization
      await new Promise(resolve => setTimeout(resolve, 300)); // Brief pause

      const optimizedTour = TwoOpt.improve([...initialTour], graph);
      const optimizedLength = calculateTourLength(optimizedTour, graph);

      // Visualize optimized tour
      visualizeTour(containerOptimized, points, optimizedTour, "green");
      const optimizedEfficiency = calculateEfficiency(optimizedLength, lowerBound, upperBound);

      document.getElementById('stats-optimized').innerHTML = `
        <div><strong>Points:</strong> ${NUM_POINTS}</div>
        <div><strong>Path Length:</strong> ${optimizedLength.toFixed(2)}</div>
        <div><strong>Bounds:</strong> [${lowerBound.toFixed(2)}, ${upperBound.toFixed(2)}]</div>
        <div><strong>Efficiency:</strong> ${optimizedEfficiency.toFixed(2)}%</div>
      `;

      // Calculate and display improvement
      const improvement = ((initialLength - optimizedLength) / initialLength * 100);
      const efficiencyGain = optimizedEfficiency - initialEfficiency;

      document.getElementById('improvement').innerHTML = `
        <div>Path Length Reduction: ${improvement.toFixed(2)}%</div>
        <div>Efficiency Improvement: +${efficiencyGain.toFixed(2)} percentage points</div>
        <div>(${initialLength.toFixed(2)} -> ${optimizedLength.toFixed(2)})</div>
      `;
    }

    // Start the comparison
    runComparison();
  </script>
</body>

</html>
