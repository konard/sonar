<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Zigzag Optimization Algorithm</title>
  <script src="algorithms/utils.js"></script>
  <script src="algorithms/angular-sort.js"></script>
  <script src="algorithms/zigzag.js"></script>
  <style>
    :root {
      font-size: 16px;
    }

    body {
      margin: 0;
      padding: 1.25rem;
      background: #f0f0f0;
      font-family: Arial, sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .header {
      text-align: center;
      margin-bottom: 1.875rem;
    }

    .header h1 {
      color: #333;
      margin-bottom: 0.5rem;
    }

    .header p {
      color: #666;
      margin: 0.25rem 0;
    }

    .header-info {
      font-size: 0.75rem;
      color: #666;
      margin-top: 0.625rem;
    }

    .header-info a {
      color: #007bff;
      text-decoration: none;
    }

    .header-info a:hover {
      text-decoration: underline;
    }

    .main-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.25rem;
      width: 100%;
      max-width: 50rem;
    }

    .canvas-container {
      position: relative;
      width: 100%;
      max-width: 31.25rem;
      padding-bottom: min(100%, 31.25rem);
      background: white;
      border: 0.0625rem solid #ccc;
      border-radius: 50%;
      box-sizing: border-box;
    }

    .canvas-inner {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .point {
      position: absolute;
      width: 0.5rem;
      height: 0.5rem;
      background: red;
      border-radius: 50%;
      transform: translate(-50%, -50%);
    }

    .line-segment {
      position: absolute;
      height: 0.125rem;
      transform-origin: left center;
      pointer-events: none;
    }

    .stats-container {
      background: white;
      border-radius: 0.625rem;
      padding: 1.25rem;
      box-shadow: 0 0.125rem 0.625rem rgba(0, 0, 0, 0.1);
      width: 100%;
      max-width: 31.25rem;
    }

    .stats {
      font-size: 0.875rem;
      color: #333;
    }

    .stats div {
      margin: 0.5rem 0;
    }

    .legend {
      display: flex;
      gap: 1.25rem;
      justify-content: center;
      margin-bottom: 0.625rem;
      font-size: 0.75rem;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.3125rem;
    }

    .legend-color {
      width: 1.25rem;
      height: 0.1875rem;
    }

    .algorithm-description {
      background: white;
      border-radius: 0.625rem;
      padding: 1.25rem;
      box-shadow: 0 0.125rem 0.625rem rgba(0, 0, 0, 0.1);
      width: 100%;
      max-width: 31.25rem;
    }

    .algorithm-description h2 {
      font-size: 1.125rem;
      margin-top: 0;
      margin-bottom: 1rem;
      color: #333;
    }

    .algorithm-description p {
      font-size: 0.875rem;
      color: #666;
      line-height: 1.6;
      margin: 0.5rem 0;
    }

    .algorithm-description ul {
      font-size: 0.875rem;
      color: #666;
      line-height: 1.6;
      padding-left: 1.25rem;
    }

    .complexity-badge {
      display: inline-block;
      background: #28a745;
      color: white;
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.75rem;
      font-weight: bold;
    }

    .progress {
      height: 0.25rem;
      background: #e9ecef;
      border-radius: 0.125rem;
      margin: 0.625rem 0;
      overflow: hidden;
    }

    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #28a745, #20c997);
      width: 0%;
      transition: width 0.1s ease;
    }

    @media (max-width: 48rem) {
      body {
        padding: 0.75rem;
      }

      .header h1 {
        font-size: 1.5rem;
      }

      .canvas-container {
        max-width: 100%;
        padding-bottom: 100%;
      }

      .stats-container,
      .algorithm-description {
        padding: 1rem;
      }
    }

    @media (max-width: 30rem) {
      :root {
        font-size: 14px;
      }
    }
  </style>
</head>

<body>
  <div class="header">
    <h1>Zigzag Optimization</h1>
    <p>Local Path Improvement by Skipping Points</p>
    <p id="grid-info" class="header-info"></p>
    <p class="header-info">
      <a href="https://github.com/konard/sonar" target="_blank" rel="noopener noreferrer">View source code on GitHub</a>
    </p>
  </div>

  <div class="main-content">
    <div class="canvas-container">
      <div class="canvas-inner" id="canvas"></div>
    </div>

    <div class="stats-container">
      <div class="legend">
        <div class="legend-item">
          <div class="legend-color" style="background: green;"></div>
          <span>Standard path</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: blue;"></div>
          <span>Zigzag optimization</span>
        </div>
      </div>
      <div class="progress"><div class="progress-bar" id="progress"></div></div>
      <div class="stats" id="stats">Initializing...</div>
    </div>

    <div class="algorithm-description">
      <h2>How Zigzag Works <span class="complexity-badge">O(n)</span></h2>
      <p>
        The Zigzag algorithm is a local optimization technique that improves a tour by checking
        if skipping intermediate points reduces the total path length.
      </p>
      <p><strong>Algorithm steps:</strong></p>
      <ul>
        <li>Start with points sorted by angle (from Angular Sort)</li>
        <li>For each group of 4 consecutive points (p1, p2, p3, p4)</li>
        <li>Compare: direct path (p1-p2-p3-p4) vs zigzag (p1-p3-p2-p4)</li>
        <li>If zigzag is shorter, apply the skip pattern</li>
      </ul>
      <p><strong>Key insight:</strong></p>
      <p>
        When points are sorted by angle but at different distances from center, the zigzag
        pattern can "cut corners" to produce a shorter path. This is particularly effective
        after Angular Sort.
      </p>
    </div>
  </div>

  <script>
    // Configuration
    const NUM_POINTS = 32;
    const GRID_SIZE = 40;

    // Use utility functions from loaded modules
    const distance = TSPUtils.distance;
    const createDistanceMatrix = TSPUtils.createDistanceMatrix;
    const calculateTourLength = TSPUtils.calculateTourLength;

    // Generate random seed for variety on each reload
    const initialSeed = Math.floor(Math.random() * 1000000);

    // Generate points on a virtual grid for consistent placement
    const generateNormalizedPoints = (numPoints, gridSize = GRID_SIZE, seed = initialSeed) => {
      let currentSeed = seed;
      const rng = () => {
        currentSeed = (currentSeed * 1103515245 + 12345) % (2 ** 31);
        return currentSeed / (2 ** 31);
      };

      const center = 0.5;
      const maxRadius = 0.45;
      const gridStep = 1 / gridSize;
      const validPositions = [];

      for (let gx = 0; gx < gridSize; gx++) {
        for (let gy = 0; gy < gridSize; gy++) {
          const x = (gx + 0.5) * gridStep;
          const y = (gy + 0.5) * gridStep;
          const dx = x - center;
          const dy = y - center;
          const distFromCenter = Math.sqrt(dx * dx + dy * dy);

          if (distFromCenter <= maxRadius) {
            // Pre-calculate angle at grid placement time
            const angle = Math.atan2(dy, dx);
            validPositions.push({
              x,
              y,
              angle: angle < 0 ? angle + 2 * Math.PI : angle,
              gx,
              gy
            });
          }
        }
      }

      // Fisher-Yates shuffle
      for (let i = validPositions.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [validPositions[i], validPositions[j]] = [validPositions[j], validPositions[i]];
      }

      const points = validPositions.slice(0, Math.min(numPoints, validPositions.length));
      return points.map((p, idx) => ({ ...p, id: idx }));
    };

    const scalePointsToPercent = (normalizedPoints) => {
      return normalizedPoints.map(p => ({
        ...p,
        percentX: p.x * 100,
        percentY: p.y * 100
      }));
    };

    // Drawing functions using percentage-based positioning
    function drawLineSegment(container, start, end, color = "green", opacity = 1) {
      const dx = end.percentX - start.percentX;
      const dy = end.percentY - start.percentY;
      const length = Math.hypot(dx, dy);
      const deg = Math.atan2(dy, dx) * 180 / Math.PI;

      const newdiv = document.createElement('div');
      newdiv.className = 'line-segment';
      newdiv.style.width = length + "%";
      newdiv.style.left = start.percentX + "%";
      newdiv.style.top = start.percentY + "%";
      newdiv.style.background = color;
      newdiv.style.opacity = opacity;
      newdiv.style.transform = "rotate(" + deg + "deg)";

      container.appendChild(newdiv);
    }

    function displayPoints(container, points) {
      points.forEach(({ percentX, percentY }) => {
        const pointDiv = document.createElement('div');
        pointDiv.classList.add('point');
        pointDiv.style.left = percentX + "%";
        pointDiv.style.top = percentY + "%";
        container.appendChild(pointDiv);
      });
    }

    // Check if zigzag pattern is better for a group of 4 points
    function shouldZigzag(p1, p2, p3, p4) {
      const directDist = TSPUtils.distance(p1, p2) + TSPUtils.distance(p3, p4);
      const zigzagDist = TSPUtils.distance(p1, p3) + TSPUtils.distance(p2, p4);
      return zigzagDist < directDist;
    }

    // Main execution with animated construction
    async function runZigzagVisualization() {
      const container = document.getElementById('canvas');
      const statsDiv = document.getElementById('stats');
      const progressBar = document.getElementById('progress');

      // Generate normalized points (each with pre-calculated angle)
      const normalizedPoints = generateNormalizedPoints(NUM_POINTS);
      const points = scalePointsToPercent(normalizedPoints);
      const graph = createDistanceMatrix(points);

      // Display points
      displayPoints(container, points);

      // Update grid info
      document.getElementById('grid-info').textContent =
        `${NUM_POINTS} points on a ${GRID_SIZE}x${GRID_SIZE} virtual grid`;

      // Sort points by angle for zigzag algorithm
      const sortedIndices = [...Array(points.length).keys()].sort((a, b) =>
        normalizedPoints[a].angle - normalizedPoints[b].angle
      );

      // Animate the zigzag construction
      let i = 0;
      let zigzagCount = 0;
      const tour = [];

      function animateStep() {
        if (i < sortedIndices.length) {
          const n = sortedIndices.length;

          // Check if we should apply zigzag
          if (n - i > 2) {
            const p1 = points[sortedIndices[(i) % n]];
            const p2 = points[sortedIndices[(i + 1) % n]];
            const p3 = points[sortedIndices[(i + 2) % n]];
            const p4 = points[sortedIndices[(i + 3) % n]];

            if (shouldZigzag(p1, p2, p3, p4)) {
              // Zigzag pattern: p1 -> p3 -> p2 -> p4
              drawLineSegment(container, p1, p3, "blue", 0.7);
              drawLineSegment(container, p3, p2, "blue", 0.7);
              drawLineSegment(container, p2, p4, "blue", 0.7);
              tour.push(sortedIndices[i], sortedIndices[i + 2], sortedIndices[i + 1]);
              i += 3;
              zigzagCount++;
            } else {
              // Normal connection
              drawLineSegment(container, p1, p2, "green", 0.7);
              tour.push(sortedIndices[i]);
              i++;
            }
          } else {
            // Connect remaining points normally
            const current = points[sortedIndices[i]];
            const next = points[sortedIndices[(i + 1) % n]];
            drawLineSegment(container, current, next, "green", 0.7);
            tour.push(sortedIndices[i]);
            i++;
          }

          progressBar.style.width = (i / sortedIndices.length * 100) + '%';
          requestAnimationFrame(animateStep);
        } else {
          // Add remaining points to tour and close the loop
          while (tour.length < sortedIndices.length) {
            const missing = sortedIndices.find(idx => !tour.includes(idx));
            if (missing !== undefined) tour.push(missing);
            else break;
          }

          // Close the tour
          const lastIdx = tour[tour.length - 1];
          const firstIdx = tour[0];
          drawLineSegment(container, points[lastIdx], points[firstIdx], "green", 0.7);

          // Calculate final statistics
          const pathLength = calculateTourLength(tour, graph);

          // Calculate what angular sort alone would give
          const angularTour = AngularSort.generateTour(normalizedPoints);
          const angularLength = calculateTourLength(angularTour, graph);

          const improvement = ((angularLength - pathLength) / angularLength * 100);

          statsDiv.innerHTML = `
            <div><strong>Algorithm:</strong> Angular Sort + Zigzag</div>
            <div><strong>Points:</strong> ${NUM_POINTS}</div>
            <div><strong>Angular Sort Path:</strong> ${angularLength.toFixed(2)}</div>
            <div><strong>After Zigzag:</strong> ${pathLength.toFixed(2)}</div>
            <div><strong>Zigzag applications:</strong> ${zigzagCount}</div>
            <div><strong>Improvement:</strong> ${improvement.toFixed(2)}%</div>
          `;
        }
      }

      // Start animation
      statsDiv.innerHTML = '<div>Building path with zigzag optimization...</div>';
      animateStep();
    }

    // Start visualization when page loads
    runZigzagVisualization();
  </script>
</body>

</html>
